\documentclass[acmsmall]{acmart}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[british]{babel}

\usepackage{bm}
\usepackage{braket}
\usepackage{mathtools}
\usepackage{mathpartir}
\usepackage[all,cmtip]{xy}
\usepackage{bussproofs}
\EnableBpAbbreviations

\usepackage{xfrac,xspace}
\usepackage{xcolor}
\usepackage{subcaption}
\usepackage{hyperref}
\usepackage[capitalise,noabbrev]{cleveref}
\usepackage[inline]{enumitem} % for environment enumerate*

\usepackage[draft]{fixme}
\usepackage{subfiles}

\usepackage{microtype}


\FXRegisterAuthor{LT}{LTan}{L-T}
\FXRegisterAuthor{Josh}{Joshan}{Josh}

\citestyle{acmauthoryear}

\AtEndPreamble{%
\theoremstyle{acmdefinition}
\newtheorem{remark}[theorem]{Remark}}

\input{type-notation} %% for type theory notation copied from HoTT Book
\input{macros}

\begin{document}

\author{Liang-Ting Chen}
\email{liang.ting.chen.tw@gmail.com}
\orcid{0000-0002-3250-1331}
\author{Hsiang-Shang Ko}
\orcid{0000-0002-2439-1048}
\email{joshko@iis.sinica.edu.tw}

\affiliation{%
  \institution{Academia Sinica}
  \streetaddress{128 Academia Road}
  \city{Taipei}
  \country{Taiwan}
  \postcode{115}
}

\title{A Formal Theory of Bidirectional Typing for Simple Types}

\begin{abstract}
  This paper proposes a formal theory of bidirectional typing.
\end{abstract}

\maketitle
\section{Introduction}\label{sec:intro}

\subsection{Related work}

\subsubsection{Language formalization and its frameworks}
\cite{Wadler2022}
PoplMark Challenge~\citep{Aydemir2005}

\cite{Cimini2020,Cimini2022}
\citep{Fiore2022}
\cite{Allais2021,Gheri2020,Ahrens2022}

\subsubsection{Algebraic theory of type theories}
\cite{Fiore1999,Fiore2022,Hamana2022,Ahrens2021,Arkor2020}


\subsubsection{Type checker generation}
\cite{Gast2004,Grewe2015,Pacak2020,Cimini2020}

\subsubsection{Bidirectional typing}
\cite{Dunfield2021}

\subsection{Plan and Contributions of this paper}

\section{Bidirectional simply typed \texorpdfstring{$\lambda$}{lambda}-calculus}\label{sec:bi-stlc}
\begin{figure}
  \begin{mathpar}
    \boxed{\Gamma \vdash \isTerm{t} \Rightarrow A}
    \quad\text{and}\quad \boxed{\Gamma \vdash \isTerm{t} \Leftarrow A}
    \\
    \inferrule{(x : A) \in \Gamma}{\Gamma \vdash \isTerm{x} \Rightarrow A}\;(\text{var}^\Rightarrow)
    \and
    \inferrule{\Gamma \vdash \isTerm{t} \Leftarrow B \\ A = B}{\Gamma \vdash \isTerm{t : B}\Rightarrow A}\;(\text{anno})
    \and
    \inferrule{\Gamma \vdash \isTerm{t} \Rightarrow B \\ A = B}{\Gamma \vdash \isTerm{t\uparrow} \Leftarrow A}\;(\text{sub})
    \and
    \inferrule{\Gamma \vdash \isTerm{t} \Rightarrow A \bto B \\ \Gamma \vdash \isTerm{u} \Leftarrow A}{\Gamma \vdash \isTerm{t\;u} \Rightarrow B}
    \and
    \inferrule{\Gamma, \isTerm{x} : A \vdash \isTerm{t} \Rightarrow B}{\Gamma \vdash \isTerm{\lam{x}t} \Rightarrow A \bto B}
  \end{mathpar}
  \caption{The extrinsic style of bidirectional simply typed $\lambda$-calculus}
  \label{fig:bi-stlc}
\end{figure}
\begin{remark}
  We avoid using the term `function type' and its conventional notation $\to$ at the object level on purpose, as it may be confused with function types in our type-theoretic meta-language.
\end{remark}

\subsection{Type Synthesis and Checking via Bidirectional Typing}
\subsection{Formalisation in \Agda}

\section{A Definition of Simple Type Theories}\label{sec:simple-type-theories}
\subsection{Simple Types}
\begin{definition}
  A \emph{(simple type) signature} $\Sigma$ consists of a set $I$ and an \emph{arity} function $\arity\colon I \to \mathbb{N}$.
  An inhabitant $i : I$ is meant to represent the \emph{$i$-th operation} $\tyOp_i$ and its \emph{number} $ \arity(i)$ of arguments.

  The judgements of \emph{$\Sigma$-types} and \emph{$\Sigma$-contexts} over a variable set $\Theta$ are defined inductively by \Cref{fig:simple-type,fig:simple-context} respectively.
We write $A : \Type_{\Sigma}(\Theta)$ for $\Theta \vdash_{\Sigma} A$ and $\Gamma \colon \Cxt_{\Sigma}(\Theta)$ for $\Theta \vdash_{\Sigma} \Gamma$ to disambiguate $\Sigma$-types and $\Sigma$-contexts in the case of any confusion.
\end{definition}

\begin{figure}
  \begin{minipage}[b]{.55\textwidth}
    \centering
    \small
    \begin{mathpar}
      \boxed{\Theta\vdash_{\Sigma} A} \\
      \inferrule{\Theta \ni X_i}{\Theta \vdash_\Sigma X_i} \and
      \inferrule{\Theta \vdash_{\Sigma} A_1 \\ \cdots \\ \Theta \vdash_{\Sigma} A_n}{\Theta \vdash_{\Sigma} \tyOp_i(A_1, \ldots, A_n)}
    \end{mathpar}
    where $n = \arity_i$
    \caption{Type formation}
    \label{fig:simple-type}
  \end{minipage}
  \begin{minipage}[b]{.4\textwidth}
    \centering
    \small
    \begin{mathpar}
      \boxed{\Theta \vdash_{\Sigma} \Gamma} \\
      \inferrule{ }{\Theta \vdash_{\Sigma} \cdot }\and
      \inferrule{\Theta \vdash_{\Sigma} A \\ \Theta\vdash_{\Sigma} \Gamma}{\Theta \vdash_{\Sigma} \Gamma, A}
    \end{mathpar}
    \caption{Context formation}
  \label{fig:simple-context}
  \end{minipage}
\end{figure}

\begin{example}\label{ex:implication}
  Simply typed $\lambda$-calculus typically has a binary implication type $\bto$ and some base types so that the set of all types is at least inhabited.
  In our setting, the set of $\Sigma$-types over $\Theta$ may have variables from $\Theta$, so $\Type_{\Sigma}(\Theta)$ is inhabited if $\Theta$ is.
  Hence, there is no need to introduce base types which are not introduced by any term construct.
  The type signature $\Sigma_{\bto}$ of simply typed $\lambda$-calculus is thus given solely by an operation $\bto$ with $\arity(\bto) = 2$, i.e.\ a binary operation.
  For simply typed $\lambda$-calculus with binary products, we can augment
  $\Sigma_{\bto}$ by adding a binary operation $\btimes$ for the binary product type.
  We denote this augmented signature by $\Sigma_{\bto, \btimes}$.
  
\end{example}


\subsection{Binding Signatures and Intrinsically Typed Terms}
\begin{definition}\label{def:binding-signature}
  For a type signature $\Sigma$, a \emph{binding signature} $\Omega$ consists of a set $O$ and a function
  \[
    \mathit{ar}\colon O \to \sum_{\Xi : \UU} \left(\Cxt_\Sigma(\Xi) \times \Type_\Sigma(\Xi)\right)^* \times \Type_\Sigma(\Xi).
  \]
  Each inhabitant $o: O$ is meant to represent a term construct $\termOp_o$ in a simple type theory with a triple $\left(\Xi, \left[\left(\Delta_1; A_1\right), \ldots, \left(\Delta_{n}; A_{n}\right) \right], A\right)$
  instead of a number as its arity $\arity_o$ where
  \begin{enumerate}
    \item $A : \Type_\Sigma(\Xi)$ is the target type of $\termOp_o$ and
    \item $\left[\left(\Delta_1; A_{1}\right), \ldots, \left(\Delta_{n}; A_{n}\right) \right]$ is a list of pairs where
    \item the $i$-th pair $(\Delta_i, A_i) :\Cxt_{\Sigma}(\Xi) \times \Term_{\Sigma}(\Xi)$ are types of the binding variables and the type of the $i$-th argument of $\termOp_{o}$.
  \end{enumerate}
  For brevity, we write $o \colon \Xi \vdash (\Delta_1)A_{1}, \ldots, \left[\Delta_{n}\right] A_{n} \to A$ to indicate an operation $o$ with its arity. 
\end{definition}
\begin{remark}[Terminology on binding signature]
  \cite{Aczel1978,Fiore2010}
\end{remark}


\begin{example} \label{ex:STLC-sig}
  Given the type signature $\Sigma_{\bto}$ for the implication type, the term signature $\Lambda_{\bto}$ for simply typed $\lambda$-calculus can be described by operations
  \begin{align*}
    \mathsf{app}\colon A, B \vdash (A \bto B), A \to B && \mathsf{abs}\colon A , B \vdash [A]B \to (A \bto B)
  \end{align*}
    or, verbosely, the signature $\Lambda_{\bto}$ consists of the type $O_\Lambda = \{\app, \abs\}$ with arities
  \begin{align*}
    \arity(\app) = (\{A, B\}, [(\cdot; A \bto B), (\cdot; A)], B)
    && 
    \arity(\abs) = (\{A, B\}, [(\cdot, A; B)], A \bto B)
  \end{align*}
\end{example}

\begin{example}\label{ex:STLCx-sig}
  For the type signature $\Sigma_{\bto, \btimes}$, the term signature $\Omega_{\bto, \btimes}$ for simply typed $\lambda$-calculus with finite products has three additional operations
to $\Omega_{\bto}$:
  \begin{align*}
    \mathsf{pair}\colon A, B \vdash A, B \to A \btimes B
    && \fst \colon A, B \vdash A \btimes B \to A
    && \snd \colon A, B \vdash A \btimes B \to B
  \end{align*}
\end{example}

\begin{figure}
  \centering
  \small
  \begin{mathpar}
    \boxed{\Theta \mid \Gamma_{\Sigma, \Omega} \vdash A} \quad \text{where $\Theta \vdash_{\Sigma} \Gamma$ and $\Theta \vdash_{\Sigma} A$} \\
    \inferrule{A \in \Gamma}{\Theta \mid \Gamma \vdash_{\Sigma, \Omega} A}\;(\var)
    \and
    \inferrule{\rho : \Xi \to \Theta \\\Theta \mid \Gamma, \simsub{\Delta_{1}}{\rho} \vdash_{\Sigma, \Omega} \simsub{A_{1}}{\rho} \\ \cdots \\ \Theta \mid \Gamma, \simsub{\Delta_{n}}{\rho} \vdash_{\Sigma, \Omega} \simsub{A_{n}}{\rho}}
    {\Theta \mid \Gamma \vdash_{\Sigma, \Omega} \simsub{A}{\rho}}\;(\termOp_o)
  \end{mathpar}
  for $o\colon \Xi \vdash [\Delta_1]A_1, \ldots, [\Delta_{n}]A_{n} \to A$ in $\Omega$
  \caption{Intrinsic typing rules}
\end{figure}

\subsection{Raw Terms and Extrinsically Typed Terms?}
\begin{LTannote}{no extrinsic typing}
Argue that we don't need extrinsically typed terms but raw terms only as the output of some parser.
\end{LTannote}

\begin{figure}
  \centering
  \begin{mathpar}
    \boxed{\Theta \vdash_{\Sigma, \Omega} t}
  \end{mathpar}
  
  \caption{Raw terms}
\end{figure}

\section{Definitions of Bidirectional Simple Type Systems} 

\subsection{Bidirectional Binding Signatures}

\begin{definition}
  For a type signature $\Sigma$, a \emph{bidirectional binding signature} $\Omega$ is a set $O$ with a function
  \[
    \mathit{ar}\colon O \to \sum_{\Xi : \UU} \left(\Cxt_{\Sigma}(\Xi) \times \Mode \times \Type_{\Sigma}(\Xi)\right)^* \times \Mode \times \Type_{\Sigma}(\Xi).
  \]
  Bidirectional binding signatures are just binding signatures (\Cref{def:binding-signature}) augmented with a mode for each argument and its target of a construct $\termOp_o$ in a bidirectional system, i.e.
  an arity is a $4$-tuple
  \[
    \left(\Xi, \left[\left(\Delta_1, \leftrightarrows_1, A_1\right), \ldots, \left(\Delta_{n}, \leftrightarrows_n, A_{n}\right) \right], \leftrightarrows, A\right)
  \]
  where ${\leftrightarrows_i}$ and ${\leftrightarrows}$ are of type $\Mode$ indicating the modes of a construct and its arguments respectively.
  For brevity, we write $o \colon \Xi \vdash [\Delta_1]A_{1}^{\leftrightarrows_1}, \ldots, [\Delta_{n}] A^{\leftrightarrows_n}_{n} \to A^{\leftrightarrows}$ to indicate an operation $o$ with its arity. 
\end{definition}

\begin{example}
  With the type signature $\Sigma_{\bto}$, the term signature $\Lambda_{\bto}^{\leftrightarrows}$ for bidirectional simply typed $\lambda$-calculus introduced in \Cref{sec:bi-stlc} can be specified by operations 
  \begin{align*}
    \mathsf{app}\colon A, B \vdash (A \bto B)^{\Rightarrow}, A^{\Leftarrow} \to B^{\Rightarrow} &&
    \mathsf{abs}\colon A , B \vdash [A]B^{\Leftarrow} \to (A \bto B)^{\Leftarrow}
  \end{align*}
  like those in \Cref{ex:STLC-sig} but augmented with the mode information.
\end{example}

\subsection{Bidirectionally Typed Terms: Intrinsic Typing vs.\ Extrinsic Typing}

\subsubsection{Intrinsically Typed Terms}

\subsubsection{Bidirectional Raw Terms}

\begin{figure}
  \centering
  \begin{mathpar}
    \boxed{\Theta \vdash_{\Sigma, \Omega} t \Rightarrow}
    \quad\text{and}\quad
    \boxed{\Theta \vdash_{\Sigma, \Omega} t \Leftarrow}
  \end{mathpar}
  
  \caption{Bidirectional raw terms}
\end{figure}

\subsubsection{Extrinsically Typed Terms}

\begin{figure}
  \centering
  \small
  \begin{mathpar}
    \boxed{\Theta \mid \Gamma \vdash_{\Sigma, \Omega} \isTerm{t} \Rightarrow A}\quad\text{and}\quad\boxed{\Theta \mid \Gamma \vdash_{\Sigma, \Omega} \isTerm{t} \Leftarrow A} 
    \quad \text{where $\Theta \vdash_{\Sigma} \Gamma$, $\Theta \vdash_{\Sigma} A$, and $\Theta \vdash_{\Sigma, \Omega} t \leftrightarrows$} 
    \\
    \inferrule{(x : A) \in \Gamma}{\Theta \mid \Gamma \vdash_{\Sigma, \Omega} \isTerm{x} \mathrel{\color{red}\Rightarrow} A}\;(\var^{\Rightarrow})
    \and
    \inferrule{\Theta\mid \Gamma \vdash_{\Sigma, \Omega} \isTerm{t} \Leftarrow B \\ A = B}{\Theta \mid \Gamma \vdash_{\Sigma, \Omega} \isTerm{t : B}\Rightarrow A}\;(\textcolor{red}{anno})
    \and
    \inferrule{\Theta\mid \Gamma \vdash_{\Sigma, \Omega} \isTerm{t} \Rightarrow B \\ A = B}{\Theta \mid \Gamma \vdash_{\Sigma, \Omega} \isTerm{t\uparrow} \Leftarrow A}\;(\textcolor{red}{sub})
    \and
    \inferrule{\rho\colon \Xi \to \Theta \\
      \Theta \mid \Gamma, \simsub{\isTerm{\vec{x}_{1}} : \Delta_{1}}{\rho} \vdash_{\Sigma, \Omega} \isTerm{t_{1}} \mathrel{\color{red}\leftrightarrows_{1}} \simsub{A_{1}}{\rho} \\
      \cdots \\
    \Theta \mid \Gamma, \simsub{\isTerm{\vec{x}_{n}} : \Delta_{n}}{\rho} \vdash_{\Sigma, \Omega} \isTerm{t_n} \mathrel{\color{red}\leftrightarrows_{n}} \simsub{A_{n}}{\rho}}
    {\Theta \mid \Gamma \vdash_{\Sigma, \Omega} \isTerm{\termOp_o(\vec{x}_1 .\, t_{1}; \ldots; \vec{x}_{n}.\, t_{n})} \mathrel{\color{red}\leftrightarrows} \simsub{A}{\rho}} \; (\termOp^{\leftrightarrows}_o)
  \end{mathpar}
  for $o \colon \Xi \vdash [\Delta_1]A_{1}^{\leftrightarrows_1}, \ldots, [\Delta_{n}] A^{\leftrightarrows_n}_{n} \to A^{\leftrightarrows}$ in $\Omega$
  \caption{Bidirectional extrinsic typing rules}
\end{figure}

\begin{example}
  
\end{example}


\subsection{Binding Signatures vs.\ their Bidirectional Variants}
\subsubsection{Soundness}
\subsubsection{Completeness (Annotatability)}
\subsection{Mode Correctness}

\section{Bidirectional Type Synthesis and Checking}

\subsection{Substitution Properties}
\subsection{Generic First-Order Unification}
\cite{McBride2003,McBride2003a}
\begin{definition}
A \emph{decidable equality} for a type $X$ is a dependent function $\prod_{x, y : X} \left(\id{x}{y}\right) + \neg \left(\id{x}{y}\right)$.
\end{definition}
 
\subsection{Uniqueness of Synthesis}

\subsection{Type Synthesis and Checking with Unification}

\section{Formal Implementation and Examples}

\citep{Xie2018}

\section{Future Work}
\begin{acks}
We thank Nathanael Arkor for the useful conversation and to thank the Programming Languages and Formal Methods Laboratory at Academia Sinica for the opportunity of sharing earlier ideas.

The work is supported by the Ministry of Science and Technology of Taiwan under grant MOST 109-2222-E-001-002-MY3.
\end{acks}

\bibliographystyle{ACM-Reference-Format}

\IfFileExists{reference.bib}{%
  \bibliography{reference}
}{\bibliography{ref}}

\end{document}
