%!TEX root = BiSig.tex

\section{Examples}\label{sec:example}
To exhibit the applicability of our approach, we discuss two more examples:
one has infinitely many operations and the other includes many more constructs than simply typed $\lambda$-calculus, exhibiting the practical side of a general treatment.

\subsection{Spine application}\label{subsec:spine}
A spine application $t\;u_1\;\ldots\;u_n$ is a form of application that consists of a head term $t$ and an indeterminate number of arguments $u_1\;u_2\;\dots\;u_n$.
This arrangement allows direct access to the head term, making it practical in various applications, and has been used by \Agda's core language. %employs this form of application, as does its reflected syntax used for metaprogramming.

At first glance, accommodating this form of application may seem impossible, given that the number of arguments for a construct is finite and has to be fixed.
Nonetheless, the total number of operation symbols a signature can have need not be finite, allowing us to establish a corresponding construct for each number $n$ of arguments, i.e.\ viewing the following rule
\bgroup
\small
  \begin{mathpar}
    \inferrule{\Gamma \vdash t \syn A_1 \bto \left(A_2 \bto \left(\dots \bto \left(A_n \bto B\right)\ldots\right)\right) \and \Gamma \vdash u_1 \chk A_1 \and \dots \and \Gamma \vdash u_n \chk A_n}{\Gamma \vdash t\;u_1\;\ldots\;u_n \syn B}
  \end{mathpar}
\egroup
as a rule schema parametrised by $n$, so the signature $\Omega_{\Lambda}^{\Leftrightarrow}$ can be extended with 
\[
  \aritysymbol{\mathsf{app}_n}{A_1,\ldots, A_n, B}{A_1 \bto \left(A_2 \bto \left(\dots \bto \left(A_n \bto B\right)\ldots\right)\right)^{\syn}, A_1^{\chk}, \ldots, A_n^{\chk}}{B}
\]
Each application $t\;u_1\;\ldots\;u_n$ can be introduced as $\tmOp_{\mathsf{app}_n}(t; u_1; \ldots; u_n)$, thereby exhibiting the necessity of having an arbitrary set for operation symbols.

\subsection{Computational calculi}\label{subsec:PCF}
Implementing a standalone type synthesizer for a simply typed language is typically a straightforward task.
However, the code size increases proportionally to the number of type constructs and of arguments associated with each term construct.
When dealing with a fixed number of $n$ type constructs, for each synthesising construct, there are two cases for a checking argument but $n + 1$ possible cases for each synthesising argument---the successful synthesis of the expected type, instances where it fails, or $n-1$ cases where the expected type does not match; similarly for a checking construct---making the task tedious and error-prone.
Therefore, having a generator can be helpful and significantly reduce the effort for implementation.

For illustrative purposes, consider a computational calculus~\cite{Moggi1989} with additional constructs listed in \cref{tab:computational-calculus}.
The extended language has `only' 15 constructs, far fewer than a realistic programming language would have, but there are nearly 100 possible cases already to consider during bidirectional type synthesis.
\begin{table}[h!]
  \renewcommand{\arraystretch}{2.3}
  \setlength{\tabcolsep}{3pt}
  \centering\footnotesize
\begin{tabular}{c | l}
  Rules & Operations \\ \hline\hline
  $\inferrule{ }{\Gamma \vdash \mathtt{z} \chk \mathtt{nat}}$ &  $\aritysymbol{\mathsf{z}}{\cdot}{\cdot}{\mathtt{nat}^{\chk}}$ 
  \\
 $\inferrule{\Gamma \vdash t \chk \mathtt{nat}}{\Gamma \vdash \mathtt{s}(t) \chk \mathtt{nat}}$ & $\aritysymbol{\mathsf{s}}{\cdot}{\mathtt{nat}^{\chk}}{\mathtt{nat}^{\chk}}$ \\
 $\inferrule{\Gamma \vdash t \syn \mathtt{nat} \and \Gamma \vdash t_0 \chk A \and \Gamma, x : \mathtt{nat} \vdash t_1 \chk A}{\Gamma \vdash \mathtt{ifz}(t_0; x.t_1)(t) \chk A}$ & $\aritysymbol{\mathsf{ifz}}{A}{\mathtt{nat}^{\syn}, A^{\chk}, A^{\chk}}{A^{\chk}}$ \\
 $\inferrule{\Gamma \vdash t \chk A \and \Gamma \vdash u \chk B}{\Gamma \vdash (t, u) \chk A \times B}$ & $\aritysymbol{\mathsf{pair}}{A, B}{A^{\chk}, B^{\chk}}{A \times B^{\chk}}$  \\
 $\inferrule{\Gamma \vdash t \syn A_1 \times A_2}{\Gamma \vdash \mathtt{proj}_i(t) \syn A_i}$ for $i = 1, 2$ & $\aritysymbol{\mathsf{proj}_i}{A_1, A_2}{A_1 \times A_2^{\syn}}{A_i^{\syn}}$ for $i = 1, 2$ \\

 $\inferrule{\Gamma \vdash t \chk A_i}{\Gamma \vdash \mathtt{inj}_i(t) \chk A_1 + A_2}$ for $i = 1, 2$ & $\aritysymbol{\mathsf{inj}_i}{A_1, A_2}{A_i^{\chk}}{A_1 + A_2^{\chk}}$ for $i = 1, 2$ \\

 $\inferrule{\Gamma \vdash u \syn A + B \and \Gamma, x_1 : A \vdash t_1 \chk C \and \Gamma, x_2 : B \vdash t_2 \chk C}{\Gamma \vdash \mathtt{case}(u; x_1. t_1; x_2. t_2) \chk C}$ & $\aritysymbol{\mathsf{case}}{A, B, C}{{A + B}^{\syn}, [A]C^{\chk}, [B]C^{\chk}}{C^{\syn}}$ \\

 $\inferrule{\Gamma, x : A \vdash t \chk A}{\Gamma \vdash \mu x.\, t \chk A}$ & $\aritysymbol{\mathsf{mu}}{A}{[A]A^{\chk}}{A^{\chk}}$ \\

 $\inferrule{\Gamma \vdash t \syn A \and \Gamma, x : A \vdash u \chk B}{\Gamma \vdash \mathtt{let}\;x = t\;\mathtt{in}\;u\chk B}$ & 
  $\aritysymbol{\mathsf{let}}{A, B}{A^{\syn},[A]B^{\chk}}{B^{\chk}}$ \\
 $\inferrule{\Gamma \vdash t \syn A}{\Gamma \vdash \mathtt{ret}(t) \syn T(A)}$ & $\aritysymbol{\mathsf{ret}}{A}{A^{\syn}}{T(A)^{\syn}}$ \\
 $\inferrule{\Gamma \vdash t \syn T(A) \and \Gamma, x : A \vdash u \syn T(B)}{\Gamma \vdash \mathtt{bind}(t; x.u) \syn T(B)}$ & $\aritysymbol{\mathsf{bind}}{A, B}{T(A)^{\syn}, [A]T(B)^{\syn}}{T(B)^{\syn}}$
\end{tabular}
\caption{A computational calculus with naturals, products, sums, and general recursion}
\label{tab:computational-calculus}
\end{table}

On the other hand, similar to a parser generator, a type-synthesiser generator only needs a specification $(\Sigma, \Omega)$ from the user to produce a corresponding synthesiser. 
In more detail, such a specification can be derived by extending $\Sigma_{\bto}$ with additional type constructs with $\mathsf{nat}$, $\mathsf{prod}$, $\mathsf{sum}$, and $\mathsf{T}$ such that
\[
  \arity({\mathsf{nat}}) = 0\qquad
  \arity({\mathsf{T}}) = 1\qquad
  \arity({\mathsf{prod}}) = \arity({\mathsf{sum}}) = 2.
\]
Types $\mathtt{nat}$, $A \times B$, $A + B$, and $T(A)$ are introduced as $\tyOp_{\mathsf{nat}}$, $\tyOp_{\mathsf{prod}}(A, B)$, $\tyOp_{\mathsf{sum}}(A, B)$, and $\tyOp_{\mathsf{T}}(A)$ respectively.
The signature $\Omega_{\Lambda}^{\Leftrightarrow}$ is then extended with operations listed in \cref{tab:computational-calculus}.
Finally, invoking \cref{cor:trichotomy} formally with the specification~$(\Sigma, \Omega)$ gives us a type synthesiser directly.\footnote{%
See \cref{sec:formalisation} for a demonstration in \Agda.}
