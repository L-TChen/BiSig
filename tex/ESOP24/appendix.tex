%!TEX root = BiSig.tex

\section{Detailed definitions and proofs}\label{sec:defs-proofs}

\subsection{Mode Correctness}\label{sec:mode-correctness}
As \citet{Dunfield2021} outlined, mode-correctness for a bidirectional typing rule means that 
\begin{enumerate*}
\item each `input' type variable in a premise must be an `output' variable in `earlier' premises, or provided by the conclusion if the rule is checking;
\item each `output' type variable in the conclusion should be some `output' variable in a premise if the rule is synthesising.
\end{enumerate*}
Here `input' variables refer to variables in an extension context and in a checking premise.
It is important to note that the order of premises in a bidirectional typing rule also matters, since synthesised type variables are instantiated incrementally during type synthesis.

Consider the rule $\ChkRule{Abs}$ (\Cref{fig:STLC-bidirectional-typing-derivations}) as an example.
This rule is mode-correct, as the type variables $A$ and $B$ in its only premise are already provided by its conclusion $A \bto B$.
Likewise, the rule $\SynRule{App}$ for an application term $\isTerm{t\;u}$ is mode-correct because:
\begin{enumerate*}
\item the type $A \bto B$ of the first argument $t$ is synthesised, thereby ensuring type variables $A$ and $B$ must be known if successfully synthesised;
\item the type of the second argument $u$ is checked against $A$, which has been synthesised earlier;
\item as a result, the type of an application $t\;u$ can be synthesised.
\end{enumerate*}

Now let us define mode-correctness rigorously.
As we have outlined, the condition of mode-correctness for a synthesising rule is different from that of a checking rule, and the argument order also matters.
Defining the condition directly for a rule, and thus in our setting for an operation, can be somewhat intricate.
Instead, we choose to define the conditions for the argument list---more specifically, triples $\biargvec$ of an extension context $\Delta_i$, a type $A_i$, and a mode $\dir{d_i}$---pertaining to an operation, for an operation, and subsequently for a signature.
We also need some auxiliary definitions for the subset of variables of a type and of an extension context, and the set of variables that have been synthesised:
\begin{definition}
  The finite subset\footnote{%
  There are various definitions for finite subsets of a set within Martin-L\"{o}f type theory.
  However, for our purposes, the choice among these definitions is not a matter of concern.}
  of \emph{(free) variables} of a type $A$ is denoted by $\fv(A)$.
  The subset $\fv(\Delta)$ of variables in an extension context~$\Delta$ is defined by\/ $\fv(\cdot) = \emptyset$ and\/ $\fv(\Delta, A) = \fv(\Delta) \cup \fv(A)$.
  For an argument list $\biargs$, define its set of \emph{synthesised type variables} inductively by 
  \begin{align}
    \label{eq:synvar1}\synvar(\cdot)                   & = \emptyset  \\
    \label{eq:synvar2}\synvar(\biargs, \chkbiarg[n+1]) & = \phantom{\fv(A_{n+1}) \cup {}} \synvar(\biargs) \\
    \label{eq:synvar3}\synvar(\biargs, \synbiarg[n+1]) & = \fv(A_{n+1}) \cup           \synvar(\biargs).
  \end{align}
\end{definition}
This subset contains type variables of a synthesising argument and they are exactly those type variables that will be synthesised during type synthesis.

\begin{definition}\label{def:mode-correctness-args}
  The \emph{mode-correctness} $\MCas\left(\biargvec\right)$ for an argument list $\biargs$ with respect to a subset $S$ of $\Xi$ is a (proof-relevant) predicate defined by
  \begin{align}
    \label{eq:MC1} \MCas( \cdot ) & = \top \\
    \label{eq:MC3} \MCas\left(\biargvec, \chkbiarg[n]\right)
                                  & = \fv(\Delta_n, A_n) \subseteq \left( S \cup \synvar\left(\biargvec\right)\right) \land \MCas\left(\biargvec\right) \\
    \label{eq:MC2} \MCas\left(\biargvec, \synbiarg[n]\right) 
                                  & = \phantom{, A_n} \fv(\Delta_n) \subseteq \left( S \cup \synvar\left(\biargvec\right)\right) \land  \MCas\left(\biargvec\right)
  \end{align}
  where \eqref{eq:MC1} means an empty list is always mode-correct.
\end{definition}
This definition encapsulates the idea that every `input' type variable, possibly derived from an extension context~$\Delta_n$ or a checking argument~$A_n$, must be an `output' variable from $\synvar(\biargvec)$ or, if the rule is checking, belong to the set $S$ of `input' variables in its conclusion.
This condition must be met for every tail of the argument list as well to ensure that `output' variables accessible at each argument position are from preceding arguments only, hence an inductive definition.
\begin{definition}\label{def:mode-correctness}
  An operation $\biop$ is \emph{mode-correct} if 
  \begin{enumerate}
    \item either $d$ is $\chk$, its argument list is mode-correct with respect to $\fv(A_0)$, and the union $\fv(A_0) \cup \synvar(\biargvec)$ contains every inhabitant of $\Xi$;
    \item or $d$ is $\syn$, its argument list is mode-correct with respect to $\emptyset$, and $\synvar(\biargvec)$ contains every inhabitant of $\Xi$ and, particularly, $\fv(A_0)$.
  \end{enumerate}
  A bidirectional binding signature $\Omega$ is \emph{mode-correct} if its operations are all mode-correct.
\end{definition}
For a checking operation, an `input' variable of an argument could be derived from~$A_0$, as these are known during type checking as an input.
Since every inhabitant of~$\Xi$ can be located in either~$A_0$ or synthesised variables, we can determine a concrete type for each inhabitant of~$\Xi$ during type synthesis.
On the other hand, for a synthesising operation, we do not have any known variables at the onset of type synthesis, so the argument list should be mode-correct with respect to~$\emptyset$.
Also, the set of synthesised variables alone should include every type variable in~$\Xi$ and particularly in~$A_n$.

It is easy to check the bidirectional type system $(\Sigma_{\bto}, \Omega^{\Leftrightarrow}_{\Lambda}$) in \Cref{ex:signature-simply-typed-lambda} for simply typed $\lambda$-calculus is mode-correct according to our definition.

\begin{remark}
  Mode-correctness is fundamentally a condition for bidirectional typing \emph{rules}, not for derivations.
  Thus, this property cannot be formalised without treating rules as some mathematical object, such as the notion of bidirectional binding signature presented in \Cref{sec:defs}.
  This contrasts with the properties in \Cref{sec:pre-synthesis}, which can still be specified for individual systems even in the absence of a generic definition of bidirectional type systems.
\end{remark}

Now, we set out to show the uniqueness of synthesised types for a mode-correct bidirectional type system.
For a specific system, its proof is typically a straightforward induction on the typing derivations.
However, since mode-correctness is inductively defined on the argument list, our proof proceeds by induction on both the typing derivations and the argument list:
\begin{lemma}[Uniqueness of Synthesised Types]\label{thm:unique-syn}
  In a mode-correct bidirectional type system $(\Sigma, \Omega)$, the synthesised types of any two derivations
  \[
    \Gamma |-_{\Sigma, \Omega} \isTerm{t} \syn A
    \quad\text{and}\quad
    \Gamma |-_{\Sigma, \Omega} \isTerm{t} \syn B
  \]
  for the same term $t$ must be equal, i.e.\ $A = B$.
\end{lemma}
\begin{proof}%[Proof of \Cref{thm:unique-syn}]
  We prove the statement by induction on derivations $d_1$ and $d_2$ for $\Gamma |-_{\Sigma, \Omega} \isTerm{t} \syn A$ and $\Gamma |-_{\Sigma, \Omega} \isTerm{t} \syn B$.
  Our system is syntax-directed, so $d_1$ and $d_2$ must be derived from the same rule: 
  \begin{itemize}
    \item $\SynRule{Var}$ follows from that each variable as a raw term refers to the same variable in its context.
    \item $\SynRule{Anno}$ holds trivially, since the synthesised type $A$ is from the term $t \annotate A$ in question.
    \item $\Rule{Op}$: Recall that a derivation of\/ $\Gamma |- \tmOpts \syn A$ contains a substitution $\rho$ from the local context $\Xi$ to concrete types.
      To prove that any two typing derivations has the same synthesised type, it suffices to show that those substitutions $\rho_1$~and~$\rho_2$ of $d_1$~and~$d_2$, respectively, agree on variables in $\synvar(\biargs)$ so that $\simsub{A_0}{\rho_1} = \simsub{A_0}{\rho_2}$.
      We prove it by induction on the argument list:
      \begin{enumerate}
        \item For the empty list, the statement is vacuously true by \Cref{eq:synvar1}.
        \item If $\dir{d_{i+1}}$ is~$\chk$, then the statement holds for \Cref{eq:synvar2} by induction hypothesis.
        \item If $\dir{d_{i+1}}$ is~$\syn$, then $\simsub{\Delta_{i+1}}{\rho_1} = \simsub{\Delta_{i+1}}{\rho_2}$ by \Cref{eq:MC2} and induction hypothesis (of the list).
          Therefore, under the same context $\Gamma, \simsub{\Delta_{i+1}}{\rho_1} = \Gamma, \simsub{\Delta_{i+1}}{\rho_2}$ the term $t_{i+1}$ must have the same synthesised type $\simsub{A_{i+1}}{\rho_1} = \simsub{A_{i+1}}{\rho_1}$ by induction hypothesis (of the typing derivation), so $\rho_1$ and $\rho_2$ agree on $\fv(A_{i+1})$ in addition to $\synvar(\biargs)$, as required for \Cref{eq:synvar3} in the definition of $\synvar$.
      \end{enumerate}
  \end{itemize}
\end{proof}

%Uniqueness of the synthesised types is a prevalent property in bidirectional type systems, although the specific proofs can vary depending on the constructs in the system.
%For instance, for derivations of $\Gamma |- t\;u \syn B_i$ for $i = 1, 2$ in simply typed $\lambda$-calculus, the hypothesis is applied to their sub-derivations $\Gamma |- t \syn A_i \bto B_i$ to conclude that $A_1 \bto B_1 = A_2 \bto B_2$ and thus $B_1 = B_2$.
%On the other hand, our proof is based on mode-correctness and need not consider specific sub-derivations.

