

@article{Wells1999,
  author =        {Wells, Joe B.},
  journal =       {Annals of Pure and Applied Logic},
  month =         jun,
  number =        {1-3},
  pages =         {111--156},
  title =         {Typability and type checking in {System F} are
                   equivalent and undecidable},
  volume =        {98},
  year =          {1999},
  abstract =      {Girard and Reynolds independently invented System F
                   (a.k.a. the second-order polymorphically typed lambda
                   calculus) to handle problems in logic and computer
                   programming language design, respectively. Viewing F
                   in the Curry style, which associates types with
                   untyped lambda terms, raises the questions of
                   typability and type checking. Typability asks for a
                   term whether there exists some type it can be given.
                   Type checking asks, for a particular term and type,
                   whether the term can be given that type. The
                   decidability of these problems has been settled for
                   restrictions and extensions of F and related systems
                   and complexity lower-bounds have been determined for
                   typability in F, but this report is the first to
                   resolve whether these problems are decidable for
                   System F. This report proves that type checking in F
                   is undecidable, by a reduction from semi-unification,
                   and that typability in F is undecidable, by a
                   reduction from type checking. Because there is an
                   easy reduction from typability to type checking, the
                   two problems are equivalent. The reduction from type
                   checking to typability uses a novel method of
                   constructing lambda terms that simulate arbitrarily
                   chosen type environments. All of the results also
                   hold for the λI-calculus. {\copyright} 1999
                   Published by Elsevier Science B.V. All rights
                   reserved.},
  doi =           {10.1016/S0168-0072(98)00047-5},
  issn =          {01680072},
  url =           {https://linkinghub.elsevier.com/retrieve/pii/
                  S0168007298000475},
}

@inproceedings{Dowek1993,
  address =       {Berlin, Heidelberg},
  author =        {Dowek, Gilles},
  booktitle =     {Typed Lambda Calculi and Applications. TLCA 1993},
  editor =        {Bezem, Marc and Groote, Jan Friso},
  pages =         {139--145},
  publisher =     {Springer},
  series =        {Lecture Notes in Computer Science},
  title =         {The undecidability of typability in the
                   Lambda-Pi-calculus},
  volume =        {664},
  year =          {1993},
  abstract =      {The set of pure terms which are typable in the
                   $\lambda$II-calculus in a given context is not
                   recursive. So there is no general type inference
                   algorithm for the programming language Elf and, in
                   some cases, some type information has to be mentioned
                   by the programmer.},
  doi =           {10.1007/BFb0037103},
  isbn =          {978-3-540-47586-6},
}

@article{Dunfield2021,
  address =       {New York, NY, USA},
  author =        {Dunfield, Jana and Krishnaswami, Neel},
  journal =       {ACM Computing Surveys},
  month =         may,
  number =        {5},
  pages =         {98:1--98:38},
  publisher =     {Association for Computing Machinery},
  title =         {Bidirectional typing},
  volume =        {54},
  year =          {2021},
  abstract =      {Bidirectional typing combines two modes of typing:
                   type checking, which checks that a program satisfies
                   a known type, and type synthesis, which determines a
                   type from the program. Using checking enables
                   bidirectional typing to support features for which
                   inference is undecidable; using synthesis enables
                   bidirectional typing to avoid the large annotation
                   burden of explicitly typed languages. In addition,
                   bidirectional typing improves error locality. We
                   highlight the design principles that underlie
                   bidirectional type systems, survey the development of
                   bidirectional typing from the prehistoric period
                   before Pierce and Turner's local type inference to
                   the present day, and provide guidance for future
                   investigations.},
  doi =           {10.1145/3450952},
  issn =          {0360-0300},
}

@book{Wadler2022,
  author =        {Wadler, Philip and Kokke, Wen and Siek, Jeremy G.},
  month =         aug,
  title =         {Programming Language Foundations in \textsc{Agda}},
  year =          {2022},
  url =           {https://plfa.inf.ed.ac.uk/22.08/},
}

@unpublished{Aczel1978,
  author =        {Aczel, Peter},
  note =          {Unpublished note},
  title =         {A general {Church}--{Rosser} theorem},
  year =          {1978},
  url =           {http://www.ens-lyon.fr/LIP/REWRITING/MISC/AGeneralChurch-
                  RosserTheorem.pdf},
}

@article{McBride2003,
  author =        {McBride, Conor},
  journal =       {Journal of Functional Programming},
  number =        {6},
  pages =         {1061--1075},
  publisher =     {Cambridge University Press},
  title =         {First-order unification by structural recursion},
  volume =        {13},
  year =          {2003},
  doi =           {10.1017/S0956796803004957},
}

@unpublished{McBride2003a,
  author =        {McBride, Conor},
  note =          {Supplement to the paper `First-Order Unification by
                   Structural Recursion'},
  title =         {First-order unification by structural recursion:
                   Correctness proof},
  year =          {2003},
  url =           {http://www.strictlypositive.org/foubsr-website/},
}

@inproceedings{Moggi1989,
  address =       {Los Alamitos, Calif.},
  author =        {Moggi, Eugenio},
  booktitle =     {Proceedings of the 4th Symposium on Logic in Computer
                   Science (LICS'89)},
  pages =         {14--23},
  publisher =     {IEEE Computer Society Press},
  title =         {Computational lambda-calculus and monads},
  year =          {1989},
  doi =           {10.1109/LICS.1989.39155},
}

@article{Harper1993a,
  address =       {New York, NY, USA},
  author =        {Harper, Robert and Honsell, Furio and
                   Plotkin, Gordon},
  journal =       {Journal of ACM},
  month =         {jan},
  number =        {1},
  pages =         {143--184},
  publisher =     {Association for Computing Machinery},
  title =         {A Framework for Defining Logics},
  volume =        {40},
  year =          {1993},
  abstract =      {The Edinburgh Logical Framework (LF) provides a means
                   to define (or present) logics. It is based on a
                   general treatment of syntax, rules, and proofs by
                   means of a typed λ-calculus with dependent types.
                   Syntax is treated in a style similar to, but more
                   general than, Martin-Lo¨f's system of arities. The
                   treatment of rules and proofs focuses on his notion
                   of a judgment. Logics are represented in LF via a new
                   principle, the judgments as types principle, whereby
                   each judgment is identified with the type of its
                   proofs. This allows for a smooth treatment of
                   discharge and variable occurence conditions and leads
                   to a uniform treatment of rules and proofs whereby
                   rules are viewed as proofs of higher-order judgments
                   and proof checking is reduced to type checking. The
                   practical benefit of our treatment of formal systems
                   is that logic-independent tools, such as proof
                   editors and proof checkers, can be constructed.},
  doi =           {10.1145/138027.138060},
  issn =          {0004-5411},
  url =           {https://doi.org/10.1145/138027.138060},
}

@article{Harper2007,
  author =        {Harper, Robert and Licata, Daniel R.},
  journal =       {Journal of Functional Programming},
  number =        {4-5},
  pages =         {613--673},
  publisher =     {Cambridge University Press},
  title =         {Mechanizing metatheory in a logical framework},
  volume =        {17},
  year =          {2007},
  doi =           {10.1017/S0956796807006430},
}

@phdthesis{Uemura2021,
  author =        {Uemura, Taichi},
  month =         {July},
  note =          {ISBN: 978-94-6421-376-8},
  school =        {University of Amsterdam},
  title =         {Abstract and Concrete Type Theories},
  year =          {2021},
  abstract =      {In this thesis, we study abstract and concrete type
                   theories. We introduce an abstract notion of a type
                   theory to obtain general results in the semantics of
                   type theories, but we also provide a syntactic way of
                   presenting a type theory to allow us a further
                   investigation into a concrete type theory to obtain
                   consistency and independence results.},
  url =           {https://hdl.handle.net/11245.1/41ff0b60-64d4-4003-8182-
                  c244a9afab3b},
}

@unpublished{Bauer2020,
  author =        {Bauer, Andrej and Haselwarter, Philipp G. and
                   Lumsdaine, Peter LeFanu},
  title =         {A general definition of dependent type theories},
  year =          {2020},
  doi =           {10.48550/arXiv.2009.05539},
}

@misc{Haselwarter2021,
  author =        {Haselwarter, Philipp G. and Bauer, Andrej},
  title =         {Finitary type theories with and without contexts},
  year =          {2021},
}

@article{Bauer2022a,
  author =        {Bauer, Andrej and Komel, Anja Petkovi{\'c}},
  journal =       {Logical Methods in Computer Science},
  month =         jan,
  number =        {1},
  title =         {An extensible equality checking algorithm for
                   dependent type theories},
  volume =        {18},
  year =          {2022},
  doi =           {10.46298/lmcs-18(1:17)2022},
}

@inproceedings{Ahrens2022,
  address =       {New York, NY, USA},
  author =        {Ahrens, Benedikt and Matthes, Ralph and
                   M\"{o}rtberg, Anders},
  booktitle =     {Proceedings of the 11th ACM SIGPLAN International
                   Conference on Certified Programs and Proofs},
  pages =         {307--323},
  publisher =     {Association for Computing Machinery},
  series =        {CPP 2022},
  title =         {Implementing a category-theoretic framework for typed
                   abstract syntax},
  year =          {2022},
  abstract =      {In previous work ("From signatures to monads in
                   UniMath"),we described a category-theoretic
                   construction of abstract syntax from a signature,
                   mechanized in the UniMath library based on the Coq
                   proof assistant. In the present work, we describe
                   what was necessary to generalize that work to account
                   for simply-typed languages. First, some definitions
                   had to be generalized to account for the natural
                   appearance of non-endofunctors in the simply-typed
                   case. As it turns out, in many cases our mechanized
                   results carried over to the generalized definitions
                   without any code change. Second, an existing
                   mechanized library on 𝜔-cocontinuous functors had
                   to be extended by constructions and theorems
                   necessary for constructing multi-sorted syntax.
                   Third, the theoretical framework for the semantical
                   signatures had to be generalized from a monoidal to a
                   bicategorical setting, again to account for
                   non-endofunctors arising in the typed case. This uses
                   actions of endofunctors on functors with given
                   source, and the corresponding notion of strong
                   functors between actions, all formalized in UniMath
                   using a recently developed library of bicategory
                   theory. We explain what needed to be done to plug all
                   of these ingredients together, modularly. The main
                   result of our work is a general construction that,
                   when fed with a signature for a simply-typed
                   language, returns an implementation of that language
                   together with suitable boilerplate code, in
                   particular, a certified monadic substitution
                   operation.},
  doi =           {10.1145/3497775.3503678},
}

@article{Allais2021,
  author =        {Allais, Guillaume and Atkey, Robert and
                   Chapman, James and McBride, Conor and McKinna, James},
  journal =       {Journal of Functional Programming},
  month =         oct,
  number =        {1996},
  pages =         {e22},
  title =         {A type- and scope-safe universe of syntaxes with
                   binding: their semantics and proofs},
  volume =        {31},
  year =          {2021},
  abstract =      {The syntax of almost every programming language
                   includes a notion of binder and corresponding bound
                   occurrences, along with the accompanying notions of
                   α-equivalence, capture-avoiding substitution, typing
                   contexts, runtime environments, and so on. In the
                   past, implementing and reasoning about programming
                   languages required careful handling to maintain the
                   correct behaviour of bound variables. Modern
                   programming languages include features that enable
                   constraints like scope safety to be expressed in
                   types. Nevertheless, the programmer is still forced
                   to write the same boilerplate over again for each new
                   implementation of a scope-safe operation (e.g.,
                   renaming, substitution, desugaring, printing), and
                   then again for correctness proofs. We present an
                   expressive universe of syntaxes with binding and
                   demonstrate how to (1) implement scope-safe
                   traversals once and for all by generic programming;
                   and (2) how to derive properties of these traversals
                   by generic proving. Our universe description, generic
                   traversals and proofs, and our examples have all been
                   formalised in Agda and are available in the
                   accompanying material available online at
                   https://github.com/gallais/generic-syntax .},
  doi =           {10.1017/S0956796820000076},
  issn =          {0956-7968},
}

@article{Fiore2022,
  author =        {Fiore, Marcelo and Szamozvancev, Dmitrij},
  journal =       {Proceedings of the ACM on Programming Languages},
  month =         jan,
  number =        {POPL},
  pages =         {1--29},
  title =         {Formal metatheory of second-order abstract syntax},
  volume =        {6},
  year =          {2022},
  abstract =      {Despite extensive research both on the theoretical
                   and practical fronts, formalising, reasoning about,
                   and implementing languages with variable binding is
                   still a daunting endeavour -- repetitive boilerplate
                   and the overly complicated metatheory of
                   capture-avoiding substitution often get in the way of
                   progressing on to the actually interesting properties
                   of a language. Existing developments offer some
                   relief, however at the expense of inconvenient and
                   error-prone term encodings and lack of formal
                   foundations.},
  doi =           {10.1145/3498715},
  issn =          {2475-1421},
}

@misc{Felicissimo2023,
  author =        {Felicissimo, Thiago},
  title =         {A framework for erased syntax and bidirectional
                   typing},
  year =          {2023},
  doi =           {10.48550/arXiv.2307.08523},
}

@incollection{Hamana2011,
  address =       {Berlin, Heidelberg},
  author =        {Hamana, Makoto},
  booktitle =     {Foundations of Software Science and Computational
                   Structures. FoSSaCS 2011},
  editor =        {Hofmann, Martin},
  pages =         {381--395},
  publisher =     {Springer},
  series =        {Lecture Notes in Computer Science},
  title =         {Polymorphic abstract syntax via {Grothendieck}
                   construction},
  volume =        {6604},
  year =          {2011},
  doi =           {10.1007/978-3-642-19805-2_26},
}

