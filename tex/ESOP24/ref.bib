

@article{Wells1999,
  author =        {Wells, Joe B.},
  journal =       {Annals of Pure and Applied Logic},
  month =         jun,
  number =        {1-3},
  pages =         {111--156},
  title =         {Typability and type checking in {System F} are
                   equivalent and undecidable},
  volume =        {98},
  year =          {1999},
  abstract =      {Girard and Reynolds independently invented System F
                   (a.k.a. the second-order polymorphically typed lambda
                   calculus) to handle problems in logic and computer
                   programming language design, respectively. Viewing F
                   in the Curry style, which associates types with
                   untyped lambda terms, raises the questions of
                   typability and type checking. Typability asks for a
                   term whether there exists some type it can be given.
                   Type checking asks, for a particular term and type,
                   whether the term can be given that type. The
                   decidability of these problems has been settled for
                   restrictions and extensions of F and related systems
                   and complexity lower-bounds have been determined for
                   typability in F, but this report is the first to
                   resolve whether these problems are decidable for
                   System F. This report proves that type checking in F
                   is undecidable, by a reduction from semi-unification,
                   and that typability in F is undecidable, by a
                   reduction from type checking. Because there is an
                   easy reduction from typability to type checking, the
                   two problems are equivalent. The reduction from type
                   checking to typability uses a novel method of
                   constructing lambda terms that simulate arbitrarily
                   chosen type environments. All of the results also
                   hold for the ŒªI-calculus. {\copyright} 1999
                   Published by Elsevier Science B.V. All rights
                   reserved.},
  doi =           {10.1016/S0168-0072(98)00047-5},
  issn =          {01680072},
  url =           {https://linkinghub.elsevier.com/retrieve/pii/
                  S0168007298000475},
}

@inproceedings{Dowek1993,
  address =       {Berlin, Heidelberg},
  author =        {Dowek, Gilles},
  booktitle =     {Typed Lambda Calculi and Applications. TLCA 1993},
  editor =        {Bezem, Marc and Groote, Jan Friso},
  pages =         {139--145},
  publisher =     {Springer},
  series =        {Lecture Notes in Computer Science},
  title =         {The undecidability of typability in the
                   Lambda-Pi-calculus},
  volume =        {664},
  year =          {1993},
  abstract =      {The set of pure terms which are typable in the
                   $\lambda$II-calculus in a given context is not
                   recursive. So there is no general type inference
                   algorithm for the programming language Elf and, in
                   some cases, some type information has to be mentioned
                   by the programmer.},
  doi =           {10.1007/BFb0037103},
  isbn =          {978-3-540-47586-6},
}

@article{Dunfield2021,
  address =       {New York, NY, USA},
  author =        {Dunfield, Jana and Krishnaswami, Neel},
  journal =       {ACM Computing Surveys},
  month =         may,
  number =        {5},
  pages =         {98:1--98:38},
  publisher =     {Association for Computing Machinery},
  title =         {Bidirectional typing},
  volume =        {54},
  year =          {2021},
  abstract =      {Bidirectional typing combines two modes of typing:
                   type checking, which checks that a program satisfies
                   a known type, and type synthesis, which determines a
                   type from the program. Using checking enables
                   bidirectional typing to support features for which
                   inference is undecidable; using synthesis enables
                   bidirectional typing to avoid the large annotation
                   burden of explicitly typed languages. In addition,
                   bidirectional typing improves error locality. We
                   highlight the design principles that underlie
                   bidirectional type systems, survey the development of
                   bidirectional typing from the prehistoric period
                   before Pierce and Turner's local type inference to
                   the present day, and provide guidance for future
                   investigations.},
  doi =           {10.1145/3450952},
  issn =          {0360-0300},
}

@unpublished{Felicissimo2023,
  author =        {Felicissimo, Thiago},
  title =         {A framework for erased syntax and bidirectional
                   typing},
  year =          {2023},
}

@book{Wadler2022,
  author =        {Wadler, Philip and Kokke, Wen and Siek, Jeremy G.},
  month =         aug,
  title =         {Programming Language Foundations in \textsc{Agda}},
  year =          {2022},
  url =           {https://plfa.inf.ed.ac.uk/22.08/},
}

@unpublished{Aczel1978,
  author =        {Aczel, Peter},
  note =          {Unpublished note},
  title =         {A general {Church}--{Rosser} theorem},
  year =          {1978},
  url =           {http://www.ens-lyon.fr/LIP/REWRITING/MISC/AGeneralChurch-
                  RosserTheorem.pdf},
}

@article{McBride2003,
  author =        {McBride, Conor},
  journal =       {Journal of Functional Programming},
  number =        {6},
  pages =         {1061--1075},
  publisher =     {Cambridge University Press},
  title =         {First-order unification by structural recursion},
  volume =        {13},
  year =          {2003},
  doi =           {10.1017/S0956796803004957},
}

@unpublished{McBride2003a,
  author =        {McBride, Conor},
  note =          {Supplement to the paper `First-Order Unification by
                   Structural Recursion'},
  title =         {First-order unification by structural recursion:
                   Correctness proof},
  year =          {2003},
  url =           {http://www.strictlypositive.org/foubsr-website/},
}

@article{Harper1993a,
  address =       {New York, NY, USA},
  author =        {Harper, Robert and Honsell, Furio and
                   Plotkin, Gordon},
  journal =       {Journal of ACM},
  month =         {jan},
  number =        {1},
  pages =         {143--184},
  publisher =     {Association for Computing Machinery},
  title =         {A Framework for Defining Logics},
  volume =        {40},
  year =          {1993},
  abstract =      {The Edinburgh Logical Framework (LF) provides a means
                   to define (or present) logics. It is based on a
                   general treatment of syntax, rules, and proofs by
                   means of a typed Œª-calculus with dependent types.
                   Syntax is treated in a style similar to, but more
                   general than, Martin-Lo¬®f's system of arities. The
                   treatment of rules and proofs focuses on his notion
                   of a judgment. Logics are represented in LF via a new
                   principle, the judgments as types principle, whereby
                   each judgment is identified with the type of its
                   proofs. This allows for a smooth treatment of
                   discharge and variable occurence conditions and leads
                   to a uniform treatment of rules and proofs whereby
                   rules are viewed as proofs of higher-order judgments
                   and proof checking is reduced to type checking. The
                   practical benefit of our treatment of formal systems
                   is that logic-independent tools, such as proof
                   editors and proof checkers, can be constructed.},
  doi =           {10.1145/138027.138060},
  issn =          {0004-5411},
  url =           {https://doi.org/10.1145/138027.138060},
}

@article{Harper2007,
  author =        {Harper, Robert and Licata, Daniel R.},
  journal =       {Journal of Functional Programming},
  number =        {4-5},
  pages =         {613--673},
  publisher =     {Cambridge University Press},
  title =         {Mechanizing metatheory in a logical framework},
  volume =        {17},
  year =          {2007},
  doi =           {10.1017/S0956796807006430},
}

@inproceedings{Ahrens2022,
  address =       {New York, NY, USA},
  author =        {Ahrens, Benedikt and Matthes, Ralph and
                   M\"{o}rtberg, Anders},
  booktitle =     {Proceedings of the 11th ACM SIGPLAN International
                   Conference on Certified Programs and Proofs},
  pages =         {307--323},
  publisher =     {Association for Computing Machinery},
  series =        {CPP 2022},
  title =         {Implementing a category-theoretic framework for typed
                   abstract syntax},
  year =          {2022},
  abstract =      {In previous work ("From signatures to monads in
                   UniMath"),we described a category-theoretic
                   construction of abstract syntax from a signature,
                   mechanized in the UniMath library based on the Coq
                   proof assistant. In the present work, we describe
                   what was necessary to generalize that work to account
                   for simply-typed languages. First, some definitions
                   had to be generalized to account for the natural
                   appearance of non-endofunctors in the simply-typed
                   case. As it turns out, in many cases our mechanized
                   results carried over to the generalized definitions
                   without any code change. Second, an existing
                   mechanized library on ùúî-cocontinuous functors had
                   to be extended by constructions and theorems
                   necessary for constructing multi-sorted syntax.
                   Third, the theoretical framework for the semantical
                   signatures had to be generalized from a monoidal to a
                   bicategorical setting, again to account for
                   non-endofunctors arising in the typed case. This uses
                   actions of endofunctors on functors with given
                   source, and the corresponding notion of strong
                   functors between actions, all formalized in UniMath
                   using a recently developed library of bicategory
                   theory. We explain what needed to be done to plug all
                   of these ingredients together, modularly. The main
                   result of our work is a general construction that,
                   when fed with a signature for a simply-typed
                   language, returns an implementation of that language
                   together with suitable boilerplate code, in
                   particular, a certified monadic substitution
                   operation.},
  doi =           {10.1145/3497775.3503678},
  isbn =          {9781450391825},
  url =           {https://doi.org/10.1145/3497775.3503678},
}

@article{Allais2021,
  author =        {Allais, Guillaume and Atkey, Robert and
                   Chapman, James and McBride, Conor and McKinna, James},
  journal =       {Journal of Functional Programming},
  month =         oct,
  number =        {1996},
  pages =         {e22},
  title =         {A type- and scope-safe universe of syntaxes with
                   binding: their semantics and proofs},
  volume =        {31},
  year =          {2021},
  abstract =      {The syntax of almost every programming language
                   includes a notion of binder and corresponding bound
                   occurrences, along with the accompanying notions of
                   Œ±-equivalence, capture-avoiding substitution, typing
                   contexts, runtime environments, and so on. In the
                   past, implementing and reasoning about programming
                   languages required careful handling to maintain the
                   correct behaviour of bound variables. Modern
                   programming languages include features that enable
                   constraints like scope safety to be expressed in
                   types. Nevertheless, the programmer is still forced
                   to write the same boilerplate over again for each new
                   implementation of a scope-safe operation (e.g.,
                   renaming, substitution, desugaring, printing), and
                   then again for correctness proofs. We present an
                   expressive universe of syntaxes with binding and
                   demonstrate how to (1) implement scope-safe
                   traversals once and for all by generic programming;
                   and (2) how to derive properties of these traversals
                   by generic proving. Our universe description, generic
                   traversals and proofs, and our examples have all been
                   formalised in Agda and are available in the
                   accompanying material available online at
                   https://github.com/gallais/generic-syntax .},
  doi =           {10.1017/S0956796820000076},
  issn =          {0956-7968},
  url =           {https://www.cambridge.org/core/product/identifier/
                  S0956796820000076/type/journal_article},
}

@article{Fiore2022,
  author =        {Fiore, Marcelo and Szamozvancev, Dmitrij},
  journal =       {Proceedings of the ACM on Programming Languages},
  month =         jan,
  number =        {POPL},
  pages =         {1--29},
  title =         {Formal metatheory of second-order abstract syntax},
  volume =        {6},
  year =          {2022},
  abstract =      {Despite extensive research both on the theoretical
                   and practical fronts, formalising, reasoning about,
                   and implementing languages with variable binding is
                   still a daunting endeavour -- repetitive boilerplate
                   and the overly complicated metatheory of
                   capture-avoiding substitution often get in the way of
                   progressing on to the actually interesting properties
                   of a language. Existing developments offer some
                   relief, however at the expense of inconvenient and
                   error-prone term encodings and lack of formal
                   foundations.},
  doi =           {10.1145/3498715},
  issn =          {2475-1421},
  url =           {https://dl.acm.org/doi/10.1145/3498715},
}

@article{Pierce2000,
  address =       {New York, NY, USA},
  author =        {Pierce, Benjamin C. and Turner, David N.},
  journal =       {ACM Transactions on Programming Languages and
                   Systems},
  month =         {jan},
  number =        {1},
  pages =         {1--44},
  publisher =     {Association for Computing Machinery},
  title =         {Local type inference},
  volume =        {22},
  year =          {2000},
  abstract =      {We study two partial type inference methods for a
                   language combining subtyping and impredicative
                   polymorphism. Both methods are local in the sense
                   that missing annotations are recovered using only
                   information from adjacent nodes in the syntax tree,
                   without long-distance constraints such as unification
                   variables. One method infers type arguments in
                   polymorphic applications using a local constraint
                   solver. The other infers annotations on bound
                   variables in function abstractions by propagating
                   type constraints downward from enclosing application
                   nodes. We motivate our design choices by a
                   statistical analysis of the uses of type inference in
                   a sizable body of existing ML code.},
  doi =           {10.1145/345099.345100},
  issn =          {0164-0925},
}

@article{Peyton-Jones2007,
  author =        {Peyton Jones, Simon and Vytiniotis, Dimitrios and
                   Weirich, Stephanie and Shields, Mark},
  journal =       {Journal of Functional Programming},
  number =        {1},
  pages =         {1--82},
  publisher =     {Cambridge University Press},
  title =         {Practical type inference for arbitrary-rank types},
  volume =        {17},
  year =          {2007},
  doi =           {10.1017/S0956796806006034},
}

@inproceedings{Dunfield2013,
  address =       {New York, NY, USA},
  author =        {Dunfield, Jana and Krishnaswami, Neelakantan R.},
  booktitle =     {Proceedings of the 18th ACM SIGPLAN International
                   Conference on Functional Programming},
  pages =         {429--442},
  publisher =     {Association for Computing Machinery},
  series =        {ICFP '13},
  title =         {Complete and easy bidirectional typechecking for
                   higher-rank polymorphism},
  year =          {2013},
  abstract =      {Bidirectional typechecking, in which terms either
                   synthesize a type or are checked against a known
                   type, has become popular for its scalability (unlike
                   Damas-Milner type inference, bidirectional typing
                   remains decidable even for very expressive type
                   systems), its error reporting, and its relative ease
                   of implementation. Following design principles from
                   proof theory, bidirectional typing can be applied to
                   many type constructs. The principles underlying a
                   bidirectional approach to polymorphism, however, are
                   less obvious. We give a declarative, bidirectional
                   account of higher-rank polymorphism, grounded in
                   proof theory; this calculus enjoys many properties
                   such as eta-reduction and predictability of
                   annotations. We give an algorithm for implementing
                   the declarative system; our algorithm is remarkably
                   simple and well-behaved, despite being both sound and
                   complete.},
  doi =           {10.1145/2500365.2500582},
  isbn =          {9781450323260},
}

@inproceedings{Xie2018,
  address =       {Cham},
  author =        {Xie, Ningning and Oliveira, Bruno C. d. S.},
  booktitle =     {Programming Languages and Systems. ESOP 2018},
  editor =        {Ahmed, Amal},
  pages =         {272--299},
  publisher =     {Springer International Publishing},
  series =        {Lecture Notes in Computer Science},
  title =         {Let arguments go first},
  volume =        {10801},
  year =          {2018},
  abstract =      {Bi-directional type checking has proved to be an
                   extremely useful and versatile tool for type checking
                   and type inference. The conventional presentation of
                   bi-directional type checking consists of two modes:
                   inference mode and checked mode. In traditional
                   bi-directional type-checking, type annotations are
                   used to guide (via the checked mode) the type
                   inference/checking procedure to determine the type of
                   an expression, and type information flows from
                   functions to arguments.},
  doi =           {10.1007/978-3-319-89884-1_10},
  isbn =          {978-3-319-89884-1},
}

@inproceedings{Fiore2013,
  address =       {New Orleans, LA, USA},
  author =        {Fiore, Marcelo and Hamana, Makoto},
  booktitle =     {2013 28th Annual ACM/IEEE Symposium on Logic in
                   Computer Science},
  pages =         {520--529},
  publisher =     {IEEE},
  title =         {Multiversal polymorphic algebraic theories: Syntax,
                   semantics, translations, and equational Logic},
  year =          {2013},
  doi =           {10.1109/LICS.2013.59},
  isbn =          {978-1-4799-0413-6},
  issn =          {10436871},
}

@incollection{Hamana2011,
  address =       {Berlin, Heidelberg},
  author =        {Hamana, Makoto},
  booktitle =     {Foundations of Software Science and Computational
                   Structures. FoSSaCS 2011},
  editor =        {Hofmann, Martin},
  pages =         {381--395},
  publisher =     {Springer},
  series =        {Lecture Notes in Computer Science},
  title =         {Polymorphic abstract syntax via {Grothendieck}
                   construction},
  volume =        {6604},
  year =          {2011},
  doi =           {10.1007/978-3-642-19805-2_26},
}

