

@article{Wells1999,
  author =        {Wells, Joe B.},
  journal =       {Annals of Pure and Applied Logic},
  month =         jun,
  number =        {1-3},
  pages =         {111--156},
  title =         {Typability and type checking in {System F} are
                   equivalent and undecidable},
  volume =        {98},
  year =          {1999},
  abstract =      {Girard and Reynolds independently invented System F
                   (a.k.a. the second-order polymorphically typed lambda
                   calculus) to handle problems in logic and computer
                   programming language design, respectively. Viewing F
                   in the Curry style, which associates types with
                   untyped lambda terms, raises the questions of
                   typability and type checking. Typability asks for a
                   term whether there exists some type it can be given.
                   Type checking asks, for a particular term and type,
                   whether the term can be given that type. The
                   decidability of these problems has been settled for
                   restrictions and extensions of F and related systems
                   and complexity lower-bounds have been determined for
                   typability in F, but this report is the first to
                   resolve whether these problems are decidable for
                   System F. This report proves that type checking in F
                   is undecidable, by a reduction from semi-unification,
                   and that typability in F is undecidable, by a
                   reduction from type checking. Because there is an
                   easy reduction from typability to type checking, the
                   two problems are equivalent. The reduction from type
                   checking to typability uses a novel method of
                   constructing lambda terms that simulate arbitrarily
                   chosen type environments. All of the results also
                   hold for the λI-calculus. {\copyright} 1999
                   Published by Elsevier Science B.V. All rights
                   reserved.},
  doi =           {10.1016/S0168-0072(98)00047-5},
  issn =          {01680072},
}

@inproceedings{Dowek1993,
  address =       {Berlin, Heidelberg},
  author =        {Dowek, Gilles},
  booktitle =     {Typed Lambda Calculi and Applications. TLCA 1993},
  editor =        {Bezem, Marc and Groote, Jan Friso},
  pages =         {139--145},
  publisher =     {Springer},
  series =        {Lecture Notes in Computer Science},
  title =         {The undecidability of typability in the
                   Lambda-Pi-calculus},
  volume =        {664},
  year =          {1993},
  abstract =      {The set of pure terms which are typable in the
                   $\lambda$II-calculus in a given context is not
                   recursive. So there is no general type inference
                   algorithm for the programming language Elf and, in
                   some cases, some type information has to be mentioned
                   by the programmer.},
  doi =           {10.1007/BFb0037103},
  isbn =          {978-3-540-47586-6},
}

@article{Dunfield2021,
  address =       {New York, NY, USA},
  author =        {Dunfield, Jana and Krishnaswami, Neel},
  journal =       {ACM Computing Surveys},
  month =         may,
  number =        {5},
  pages =         {98:1--98:38},
  publisher =     {Association for Computing Machinery},
  title =         {Bidirectional typing},
  volume =        {54},
  year =          {2021},
  abstract =      {Bidirectional typing combines two modes of typing:
                   type checking, which checks that a program satisfies
                   a known type, and type synthesis, which determines a
                   type from the program. Using checking enables
                   bidirectional typing to support features for which
                   inference is undecidable; using synthesis enables
                   bidirectional typing to avoid the large annotation
                   burden of explicitly typed languages. In addition,
                   bidirectional typing improves error locality. We
                   highlight the design principles that underlie
                   bidirectional type systems, survey the development of
                   bidirectional typing from the prehistoric period
                   before Pierce and Turner's local type inference to
                   the present day, and provide guidance for future
                   investigations.},
  doi =           {10.1145/3450952},
  issn =          {0360-0300},
}

@book{Wadler2022,
  author =        {Wadler, Philip and Kokke, Wen and Siek, Jeremy G.},
  month =         aug,
  title =         {Programming Language Foundations in \textsc{Agda}},
  year =          {2022},
  url =           {https://plfa.inf.ed.ac.uk/22.08/},
}

@article{Pierce2000,
  address =       {New York, NY, USA},
  author =        {Pierce, Benjamin C. and Turner, David N.},
  journal =       {ACM Transactions on Programming Languages and
                   Systems},
  month =         {jan},
  number =        {1},
  pages =         {1--44},
  publisher =     {Association for Computing Machinery},
  title =         {Local type inference},
  volume =        {22},
  year =          {2000},
  abstract =      {We study two partial type inference methods for a
                   language combining subtyping and impredicative
                   polymorphism. Both methods are local in the sense
                   that missing annotations are recovered using only
                   information from adjacent nodes in the syntax tree,
                   without long-distance constraints such as unification
                   variables. One method infers type arguments in
                   polymorphic applications using a local constraint
                   solver. The other infers annotations on bound
                   variables in function abstractions by propagating
                   type constraints downward from enclosing application
                   nodes. We motivate our design choices by a
                   statistical analysis of the uses of type inference in
                   a sizable body of existing ML code.},
  doi =           {10.1145/345099.345100},
  issn =          {0164-0925},
}

@unpublished{Aczel1978,
  author =        {Aczel, Peter},
  note =          {Unpublished note},
  title =         {A general {Church}--{Rosser} theorem},
  year =          {1978},
  url =           {http://www.ens-lyon.fr/LIP/REWRITING/MISC/AGeneralChurch-
                  RosserTheorem.pdf},
}

@article{McBride2003,
  author =        {McBride, Conor},
  journal =       {Journal of Functional Programming},
  number =        {6},
  pages =         {1061--1075},
  publisher =     {Cambridge University Press},
  title =         {First-order unification by structural recursion},
  volume =        {13},
  year =          {2003},
  doi =           {10.1017/S0956796803004957},
}

@unpublished{McBride2003a,
  author =        {McBride, Conor},
  note =          {Supplement to the paper `First-Order Unification by
                   Structural Recursion'},
  title =         {First-order unification by structural recursion:
                   Correctness proof},
  year =          {2003},
  url =           {http://www.strictlypositive.org/foubsr-website/},
}

@inproceedings{Moggi1989,
  address =       {Los Alamitos, Calif.},
  author =        {Moggi, Eugenio},
  booktitle =     {Proceedings of the 4th Symposium on Logic in Computer
                   Science (LICS'89)},
  pages =         {14--23},
  publisher =     {IEEE Computer Society Press},
  title =         {Computational lambda-calculus and monads},
  year =          {1989},
  doi =           {10.1109/LICS.1989.39155},
}

@article{Harper1993a,
  address =       {New York, NY, USA},
  author =        {Harper, Robert and Honsell, Furio and
                   Plotkin, Gordon},
  journal =       {Journal of ACM},
  month =         {jan},
  number =        {1},
  pages =         {143--184},
  publisher =     {Association for Computing Machinery},
  title =         {A Framework for Defining Logics},
  volume =        {40},
  year =          {1993},
  abstract =      {The Edinburgh Logical Framework (LF) provides a means
                   to define (or present) logics. It is based on a
                   general treatment of syntax, rules, and proofs by
                   means of a typed λ-calculus with dependent types.
                   Syntax is treated in a style similar to, but more
                   general than, Martin-Lo¨f's system of arities. The
                   treatment of rules and proofs focuses on his notion
                   of a judgment. Logics are represented in LF via a new
                   principle, the judgments as types principle, whereby
                   each judgment is identified with the type of its
                   proofs. This allows for a smooth treatment of
                   discharge and variable occurence conditions and leads
                   to a uniform treatment of rules and proofs whereby
                   rules are viewed as proofs of higher-order judgments
                   and proof checking is reduced to type checking. The
                   practical benefit of our treatment of formal systems
                   is that logic-independent tools, such as proof
                   editors and proof checkers, can be constructed.},
  doi =           {10.1145/138027.138060},
  issn =          {0004-5411},
}

@article{Harper2007,
  author =        {Harper, Robert and Licata, Daniel R.},
  journal =       {Journal of Functional Programming},
  number =        {4-5},
  pages =         {613--673},
  publisher =     {Cambridge University Press},
  title =         {Mechanizing metatheory in a logical framework},
  volume =        {17},
  year =          {2007},
  doi =           {10.1017/S0956796807006430},
}

@unpublished{Assaf2016,
  author =        {Assaf, Ali and Burel, Guillaume and
                   Cauderlier, Rapha{\"e}l and Delahaye, David and
                   Dowek, Gilles and Dubois, Catherine and
                   Gilbert, Fr{\'e}d{\'e}ric and Halmagrand, Pierre and
                   Hermant, Olivier and Saillard, Ronan},
  title =         {Dedukti: a logical framework based on the
                   $\lambda$$\Pi$-calculus modulo theory},
  year =          {2016},
  url =           {http://www.lsv.fr/~dowek/Publi/expressing.pdf},
}

@misc{Felicissimo2023,
  author =        {Felicissimo, Thiago},
  title =         {A framework for erased syntax and bidirectional
                   typing},
  year =          {2023},
  doi =           {10.48550/arXiv.2307.08523},
}

@unpublished{Bauer2020,
  author =        {Bauer, Andrej and Haselwarter, Philipp G. and
                   Lumsdaine, Peter LeFanu},
  title =         {A general definition of dependent type theories},
  year =          {2020},
  doi =           {10.48550/arXiv.2009.05539},
}

@misc{Haselwarter2021,
  author =        {Haselwarter, Philipp G. and Bauer, Andrej},
  title =         {Finitary type theories with and without contexts},
  year =          {2021},
}

@article{Bauer2022a,
  author =        {Bauer, Andrej and Komel, Anja Petkovi{\'c}},
  journal =       {Logical Methods in Computer Science},
  month =         jan,
  number =        {1},
  title =         {An extensible equality checking algorithm for
                   dependent type theories},
  volume =        {18},
  year =          {2022},
  doi =           {10.46298/lmcs-18(1:17)2022},
}

@phdthesis{Uemura2021,
  author =        {Uemura, Taichi},
  month =         {July},
  school =        {University of Amsterdam},
  title =         {Abstract and Concrete Type Theories},
  year =          {2021},
  abstract =      {In this thesis, we study abstract and concrete type
                   theories. We introduce an abstract notion of a type
                   theory to obtain general results in the semantics of
                   type theories, but we also provide a syntactic way of
                   presenting a type theory to allow us a further
                   investigation into a concrete type theory to obtain
                   consistency and independence results.},
  isbn =          {978-94-6421-376-8},
  url =           {https://hdl.handle.net/11245.1/41ff0b60-64d4-4003-8182-
                  c244a9afab3b},
}

@inproceedings{Fiore1999,
  address =       {Trento, Italy},
  author =        {Fiore, Marcelo P. and Plotkin, Gordon D. and
                   Turi, Daniele},
  booktitle =     {Proceedings. 14th Symposium on Logic in Computer
                   Science},
  pages =         {193--202},
  publisher =     {IEEE},
  title =         {Abstract syntax and variable binding},
  year =          {1999},
  doi =           {10.1109/LICS.1999.782615},
  isbn =          {0-7695-0158-3},
}

@article{Tanaka2006,
  author =        {Tanaka, Miki and Power, A. John},
  journal =       {Higher-Order and Symbolic Computation},
  month =         sep,
  number =        {2-3},
  pages =         {305--337},
  title =         {Pseudo-distributive laws and axiomatics for variable
                   binding},
  volume =        {19},
  year =          {2006},
  doi =           {10.1007/s10990-006-8750-x},
  issn =          {1388-3690},
}

@article{Tanaka2006a,
  author =        {Tanaka, Miki and Power, John},
  journal =       {Journal of Logic and Computation},
  month =         {02},
  number =        {1},
  pages =         {5-25},
  title =         {A Unified Category-theoretic Semantics for Binding
                   Signatures in Substructural Logic},
  volume =        {16},
  year =          {2006},
  abstract =      {{Generalizing Fiore et al.'s use of the category 𝔽
                   of finite sets to model untyped Cartesian contexts
                   and Tanaka's use of the category ℙ of permutations
                   to model untyped linear contexts, we let S be an
                   arbitrary pseudo-monad on Cat and let S1 model
                   untyped contexts in general: this generality includes
                   contexts for sub-structural logics such as the Logic
                   of Bunched Implications and variants. Given a
                   pseudo-distributive law of S over the (partial)
                   pseudo-monad for free cocompletions, we define a
                   canonical substitution monoidal structure on the
                   category [(S1)op, Set], generalizing substitution
                   monoidal structures for Cartesian and linear contexts
                   and providing a natural substitution structure for
                   Bunched Implications and its variants. We give a
                   concrete description of the substitution monoidal
                   structure. We then give an axiomatic definition of a
                   binding signature, again extending the definitions
                   for Cartesian and linear contexts. We investigate
                   examples in detail, then prove the central result of
                   the paper, yielding initial algebra semantics for
                   binding signatures at the level of generality we
                   propose.}},
  doi =           {10.1093/logcom/exi070},
  issn =          {0955-792X},
}

@inproceedings{Fiore2010,
  address =       {Berlin, Heidelberg},
  author =        {Fiore, Marcelo and Hur, Chung-Kil},
  booktitle =     {Computer Science Logic. CSL 2010},
  editor =        {Dawar, Anuj and Veith, Helmut},
  pages =         {320--335},
  publisher =     {Springer Berlin Heidelberg},
  series =        {Lecture Notes in Computer Science},
  title =         {Second-order equational logic (extended abstract)},
  volume =        {6247},
  year =          {2010},
  abstract =      {We extend universal algebra and its equational logic
                   from first to second order as follows.},
  doi =           {10.1007/978-3-642-15205-4_26},
  isbn =          {978-3-642-15205-4},
}

@incollection{Hamana2011,
  address =       {Berlin, Heidelberg},
  author =        {Hamana, Makoto},
  booktitle =     {Foundations of Software Science and Computational
                   Structures. FoSSaCS 2011},
  editor =        {Hofmann, Martin},
  pages =         {381--395},
  publisher =     {Springer},
  series =        {Lecture Notes in Computer Science},
  title =         {Polymorphic abstract syntax via {Grothendieck}
                   construction},
  volume =        {6604},
  year =          {2011},
  doi =           {10.1007/978-3-642-19805-2_26},
}

@inproceedings{Fiore2013,
  address =       {New Orleans, LA, USA},
  author =        {Fiore, Marcelo and Hamana, Makoto},
  booktitle =     {2013 28th Annual ACM/IEEE Symposium on Logic in
                   Computer Science},
  pages =         {520--529},
  publisher =     {IEEE},
  title =         {Multiversal polymorphic algebraic theories: Syntax,
                   semantics, translations, and equational Logic},
  year =          {2013},
  doi =           {10.1109/LICS.2013.59},
  isbn =          {978-1-4799-0413-6},
  issn =          {10436871},
}

@inproceedings{Arkor2020,
  address =       {New York, NY, USA},
  author =        {Arkor, Nathanael and Fiore, Marcelo},
  booktitle =     {Proceedings of the 35th Annual ACM/IEEE Symposium on
                   Logic in Computer Science},
  pages =         {88--101},
  publisher =     {Association for Computing Machinery},
  series =        {LICS '20},
  title =         {Algebraic models of simple type theories: A
                   polynomial approach},
  year =          {2020},
  abstract =      {We develop algebraic models of simple type theories,
                   laying out a framework that extends universal algebra
                   to incorporate both algebraic sorting and variable
                   binding. Examples of simple type theories include the
                   unityped and simply-typed λ-calculi, the
                   computational λ-calculus, and predicate logic.Simple
                   type theories are given models in presheaf
                   categories, with structure specified by algebras of
                   polynomial endofunctors that correspond to natural
                   deduction rules. Initial models, which we construct,
                   abstractly describe the syntax of simple type
                   theories. Taking substitution structure into
                   consideration, we further provide sound and complete
                   semantics in structured cartesian multicategories.
                   This development generalises Lambek's correspondence
                   between the simply-typed λ-calculus and
                   cartesian-closed categories, to arbitrary simple type
                   theories.},
  doi =           {10.1145/3373718.3394771},
  isbn =          {9781450371049},
}

@article{Fiore2022,
  author =        {Fiore, Marcelo and Szamozvancev, Dmitrij},
  journal =       {Proceedings of the ACM on Programming Languages},
  month =         jan,
  number =        {POPL},
  pages =         {1--29},
  title =         {Formal metatheory of second-order abstract syntax},
  volume =        {6},
  year =          {2022},
  abstract =      {Despite extensive research both on the theoretical
                   and practical fronts, formalising, reasoning about,
                   and implementing languages with variable binding is
                   still a daunting endeavour -- repetitive boilerplate
                   and the overly complicated metatheory of
                   capture-avoiding substitution often get in the way of
                   progressing on to the actually interesting properties
                   of a language. Existing developments offer some
                   relief, however at the expense of inconvenient and
                   error-prone term encodings and lack of formal
                   foundations.},
  doi =           {10.1145/3498715},
  issn =          {2475-1421},
}

@inproceedings{Wood2022,
  address =       {Cham},
  author =        {Wood, James and Atkey, Robert},
  booktitle =     {Programming Languages and Systems},
  editor =        {Sergey, Ilya},
  pages =         {376--402},
  publisher =     {Springer International Publishing},
  series =        {Lecture Notes in Computer Science},
  title =         {A Framework for Substructural Type Systems},
  volume =        {13240},
  year =          {2022},
  abstract =      {Mechanisation of programming language research is of
                   growing interest, and the act of mechanising type
                   systems and their metatheory is generally becoming
                   easier as new techniques are invented. However,
                   state-of-the-art techniques mostly rely on
                   structurality of the type system --- that weakening,
                   contraction, and exchange are admissible and
                   variables can be used unrestrictedly once assumed.
                   Linear logic, and many related subsequent systems,
                   provide motivations for breaking some of these
                   assumptions.},
  doi =           {10.1007/978-3-030-99336-8_14},
  isbn =          {978-3-030-99336-8},
}

@article{Allais2021,
  author =        {Allais, Guillaume and Atkey, Robert and
                   Chapman, James and McBride, Conor and McKinna, James},
  journal =       {Journal of Functional Programming},
  month =         oct,
  number =        {1996},
  pages =         {e22},
  title =         {A type- and scope-safe universe of syntaxes with
                   binding: their semantics and proofs},
  volume =        {31},
  year =          {2021},
  abstract =      {The syntax of almost every programming language
                   includes a notion of binder and corresponding bound
                   occurrences, along with the accompanying notions of
                   α-equivalence, capture-avoiding substitution, typing
                   contexts, runtime environments, and so on. In the
                   past, implementing and reasoning about programming
                   languages required careful handling to maintain the
                   correct behaviour of bound variables. Modern
                   programming languages include features that enable
                   constraints like scope safety to be expressed in
                   types. Nevertheless, the programmer is still forced
                   to write the same boilerplate over again for each new
                   implementation of a scope-safe operation (e.g.,
                   renaming, substitution, desugaring, printing), and
                   then again for correctness proofs. We present an
                   expressive universe of syntaxes with binding and
                   demonstrate how to (1) implement scope-safe
                   traversals once and for all by generic programming;
                   and (2) how to derive properties of these traversals
                   by generic proving. Our universe description, generic
                   traversals and proofs, and our examples have all been
                   formalised in Agda and are available in the
                   accompanying material available online at
                   https://github.com/gallais/generic-syntax .},
  doi =           {10.1017/S0956796820000076},
  issn =          {0956-7968},
}

