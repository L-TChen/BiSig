

@article{Wells1999,
  author =        {Wells, Joe B.},
  journal =       {Annals of Pure and Applied Logic},
  month =         jun,
  number =        {1-3},
  pages =         {111--156},
  title =         {Typability and type checking in {System F} are
                   equivalent and undecidable},
  volume =        {98},
  year =          {1999},
  abstract =      {Girard and Reynolds independently invented System F
                   (a.k.a. the second-order polymorphically typed lambda
                   calculus) to handle problems in logic and computer
                   programming language design, respectively. Viewing F
                   in the Curry style, which associates types with
                   untyped lambda terms, raises the questions of
                   typability and type checking. Typability asks for a
                   term whether there exists some type it can be given.
                   Type checking asks, for a particular term and type,
                   whether the term can be given that type. The
                   decidability of these problems has been settled for
                   restrictions and extensions of F and related systems
                   and complexity lower-bounds have been determined for
                   typability in F, but this report is the first to
                   resolve whether these problems are decidable for
                   System F. This report proves that type checking in F
                   is undecidable, by a reduction from semi-unification,
                   and that typability in F is undecidable, by a
                   reduction from type checking. Because there is an
                   easy reduction from typability to type checking, the
                   two problems are equivalent. The reduction from type
                   checking to typability uses a novel method of
                   constructing lambda terms that simulate arbitrarily
                   chosen type environments. All of the results also
                   hold for the Î»I-calculus. {\copyright} 1999
                   Published by Elsevier Science B.V. All rights
                   reserved.},
  doi =           {10.1016/S0168-0072(98)00047-5},
  issn =          {01680072},
  url =           {https://linkinghub.elsevier.com/retrieve/pii/
                  S0168007298000475},
}

@inproceedings{Dowek1993,
  address =       {Berlin, Heidelberg},
  author =        {Dowek, Gilles},
  booktitle =     {Typed Lambda Calculi and Applications. TLCA 1993},
  editor =        {Bezem, Marc and Groote, Jan Friso},
  pages =         {139--145},
  publisher =     {Springer},
  series =        {Lecture Notes in Computer Science},
  title =         {The undecidability of typability in the
                   Lambda-Pi-calculus},
  volume =        {664},
  year =          {1993},
  abstract =      {The set of pure terms which are typable in the
                   $\lambda$II-calculus in a given context is not
                   recursive. So there is no general type inference
                   algorithm for the programming language Elf and, in
                   some cases, some type information has to be mentioned
                   by the programmer.},
  doi =           {10.1007/BFb0037103},
  isbn =          {978-3-540-47586-6},
}

@article{Dunfield2021,
  address =       {New York, NY, USA},
  author =        {Dunfield, Jana and Krishnaswami, Neel},
  journal =       {ACM Computing Surveys},
  month =         may,
  number =        {5},
  pages =         {98:1--98:38},
  publisher =     {Association for Computing Machinery},
  title =         {Bidirectional typing},
  volume =        {54},
  year =          {2021},
  abstract =      {Bidirectional typing combines two modes of typing:
                   type checking, which checks that a program satisfies
                   a known type, and type synthesis, which determines a
                   type from the program. Using checking enables
                   bidirectional typing to support features for which
                   inference is undecidable; using synthesis enables
                   bidirectional typing to avoid the large annotation
                   burden of explicitly typed languages. In addition,
                   bidirectional typing improves error locality. We
                   highlight the design principles that underlie
                   bidirectional type systems, survey the development of
                   bidirectional typing from the prehistoric period
                   before Pierce and Turner's local type inference to
                   the present day, and provide guidance for future
                   investigations.},
  doi =           {10.1145/3450952},
  issn =          {0360-0300},
  url =           {https://doi.org/10.1145/3450952},
}

@article{Pierce2000,
  address =       {New York, NY, USA},
  author =        {Pierce, Benjamin C. and Turner, David N.},
  journal =       {ACM Transactions on Programming Languages and
                   Systems},
  month =         {jan},
  number =        {1},
  pages =         {1--44},
  publisher =     {Association for Computing Machinery},
  title =         {Local type inference},
  volume =        {22},
  year =          {2000},
  abstract =      {We study two partial type inference methods for a
                   language combining subtyping and impredicative
                   polymorphism. Both methods are local in the sense
                   that missing annotations are recovered using only
                   information from adjacent nodes in the syntax tree,
                   without long-distance constraints such as unification
                   variables. One method infers type arguments in
                   polymorphic applications using a local constraint
                   solver. The other infers annotations on bound
                   variables in function abstractions by propagating
                   type constraints downward from enclosing application
                   nodes. We motivate our design choices by a
                   statistical analysis of the uses of type inference in
                   a sizable body of existing ML code.},
  doi =           {10.1145/345099.345100},
  issn =          {0164-0925},
  url =           {https://doi.org/10.1145/345099.345100},
}

@article{Peyton-Jones2007,
  author =        {Peyton Jones, Simon and Vytiniotis, Dimitrios and
                   Weirich, Stephanie and Shields, Mark},
  journal =       {Journal of Functional Programming},
  number =        {1},
  pages =         {1--82},
  publisher =     {Cambridge University Press},
  title =         {Practical type inference for arbitrary-rank types},
  volume =        {17},
  year =          {2007},
  doi =           {10.1017/S0956796806006034},
}

@inproceedings{Dunfield2013,
  address =       {New York, NY, USA},
  author =        {Dunfield, Jana and Krishnaswami, Neelakantan R.},
  booktitle =     {Proceedings of the 18th ACM SIGPLAN International
                   Conference on Functional Programming},
  pages =         {429--442},
  publisher =     {Association for Computing Machinery},
  series =        {ICFP '13},
  title =         {Complete and easy bidirectional typechecking for
                   higher-rank polymorphism},
  year =          {2013},
  abstract =      {Bidirectional typechecking, in which terms either
                   synthesize a type or are checked against a known
                   type, has become popular for its scalability (unlike
                   Damas-Milner type inference, bidirectional typing
                   remains decidable even for very expressive type
                   systems), its error reporting, and its relative ease
                   of implementation. Following design principles from
                   proof theory, bidirectional typing can be applied to
                   many type constructs. The principles underlying a
                   bidirectional approach to polymorphism, however, are
                   less obvious. We give a declarative, bidirectional
                   account of higher-rank polymorphism, grounded in
                   proof theory; this calculus enjoys many properties
                   such as eta-reduction and predictability of
                   annotations. We give an algorithm for implementing
                   the declarative system; our algorithm is remarkably
                   simple and well-behaved, despite being both sound and
                   complete.},
  doi =           {10.1145/2500365.2500582},
  isbn =          {9781450323260},
  url =           {https://doi.org/10.1145/2500365.2500582},
}

@inproceedings{Xie2018,
  address =       {Cham},
  author =        {Xie, Ningning and Oliveira, Bruno C. d. S.},
  booktitle =     {Programming Languages and Systems. ESOP 2018},
  editor =        {Ahmed, Amal},
  pages =         {272--299},
  publisher =     {Springer International Publishing},
  series =        {Lecture Notes in Computer Science},
  title =         {Let arguments go first},
  volume =        {10801},
  year =          {2018},
  abstract =      {Bi-directional type checking has proved to be an
                   extremely useful and versatile tool for type checking
                   and type inference. The conventional presentation of
                   bi-directional type checking consists of two modes:
                   inference mode and checked mode. In traditional
                   bi-directional type-checking, type annotations are
                   used to guide (via the checked mode) the type
                   inference/checking procedure to determine the type of
                   an expression, and type information flows from
                   functions to arguments.},
  doi =           {10.1007/978-3-319-89884-1_10},
  isbn =          {978-3-319-89884-1},
}

@inproceedings{Aydemir2005,
  address =       {Berlin, Heidelberg},
  author =        {Aydemir, Brian E. and Bohannon, Aaron and
                   Fairbairn, Matthew and Foster, J. Nathan and
                   Pierce, Benjamin C. and Sewell, Peter and
                   Vytiniotis, Dimitrios and Washburn, Geoffrey and
                   Weirich, Stephanie and Zdancewic, Steve},
  booktitle =     {Theorem Proving in Higher Order Logics},
  editor =        {Hurd, Joe and Melham, Tom},
  pages =         {50--65},
  publisher =     {Springer Berlin Heidelberg},
  series =        {Lecture Notes in Computer Science},
  title =         {Mechanized metatheory for the masses: {The}
                   {PoplMark} {Challenge}},
  volume =        {3603},
  year =          {2005},
  abstract =      {How close are we to a world where every paper on
                   programming languages is accompanied by an electronic
                   appendix with machine-checked proofs?},
  doi =           {10.1007/11541868_4},
  isbn =          {978-3-540-31820-0},
}

@book{Wadler2022,
  author =        {Wadler, Philip and Kokke, Wen and Siek, Jeremy G.},
  month =         aug,
  title =         {Programming Language Foundations in \textsc{Agda}},
  year =          {2022},
  url =           {https://plfa.inf.ed.ac.uk/22.08/},
}

@inproceedings{Altenkirch1993,
  address =       {Berlin, Heidelberg},
  author =        {Altenkirch, Thorsten},
  booktitle =     {Typed Lambda Calculi and Applications. TLCA 1993},
  editor =        {Bezem, Marc and Groote, Jan Friso},
  pages =         {13--28},
  publisher =     {Springer},
  series =        {Lecture Notes in Computer Science},
  title =         {A formalization of the strong normalization proof for
                   {System F} in {LEGO}},
  volume =        {664},
  year =          {1993},
  abstract =      {We describe a complete formalization of a strong
                   normalization proof for the Curry style presentation
                   of System F in LEGO. The underlying type theory is
                   the Calculus of Constructions enriched by inductive
                   types. The proof follows Girard et al [GLT89], i.e.
                   we use the notion of candidates of reducibility, but
                   we make essential use of general inductive types to
                   simplify the presentation. We discuss extensions and
                   variations of the proof: the extraction of a
                   normalization function, the use of saturated sets
                   instead of candidates, and the extension to a Church
                   Style presentation. We conclude with some general
                   observations about Computer Aided Formal Reasoning.},
  doi =           {10.1007/BFb0037095},
  isbn =          {978-3-540-47586-6},
}

@article{Ahrens2018,
  author =        {Ahrens, Benedikt and Matthes, Ralph and
                   M{\"{o}}rtberg, Anders},
  journal =       {Journal of Automated Reasoning},
  number =        {2},
  pages =         {1--34},
  publisher =     {Springer Netherlands},
  title =         {From signatures to monads in \textsf{UniMath}},
  volume =        {63},
  year =          {2018},
  doi =           {10.1007/s10817-018-9474-4},
  issn =          {0168-7433},
}

@article{Fiore2022,
  author =        {Fiore, Marcelo and Szamozvancev, Dmitrij},
  journal =       {Proceedings of the ACM on Programming Languages},
  month =         jan,
  number =        {POPL},
  pages =         {1--29},
  title =         {Formal metatheory of second-order abstract syntax},
  volume =        {6},
  year =          {2022},
  abstract =      {Despite extensive research both on the theoretical
                   and practical fronts, formalising, reasoning about,
                   and implementing languages with variable binding is
                   still a daunting endeavour -- repetitive boilerplate
                   and the overly complicated metatheory of
                   capture-avoiding substitution often get in the way of
                   progressing on to the actually interesting properties
                   of a language. Existing developments offer some
                   relief, however at the expense of inconvenient and
                   error-prone term encodings and lack of formal
                   foundations.},
  doi =           {10.1145/3498715},
  issn =          {2475-1421},
  url =           {https://dl.acm.org/doi/10.1145/3498715},
}

@article{Gheri2020,
  author =        {Gheri, Lorenzo and Popescu, Andrei},
  journal =       {Journal of Automated Reasoning},
  month =         apr,
  number =        {4},
  pages =         {641--675},
  title =         {A formalized general theory of syntax with bindings:
                   Extended version},
  volume =        {64},
  year =          {2020},
  abstract =      {We present the formalization of a theory of syntax
                   with bindings that has been developed and refined
                   over the last decade to support several large
                   formalization efforts. Terms are defined for an
                   arbitrary number of constructors of varying numbers
                   of inputs, quotiented to alpha-equivalence and sorted
                   according to a binding signature. The theory contains
                   a rich collection of properties of the standard
                   operators on terms, including substitution, swapping
                   and freshness---namely, there are lemmas showing how
                   each of the operators interacts with all the others
                   and with the syntactic constructors. The theory also
                   features induction and recursion principles and
                   support for semantic interpretation, all tailored for
                   smooth interaction with the bindings and the standard
                   operators.},
  doi =           {10.1007/s10817-019-09522-2},
  issn =          {0168-7433},
  url =           {https://doi.org/10.1007/s10817-019-09522-2},
}

@inproceedings{Ahrens2022,
  address =       {New York, NY, USA},
  author =        {Ahrens, Benedikt and Matthes, Ralph and
                   M\"{o}rtberg, Anders},
  booktitle =     {Proceedings of the 11th ACM SIGPLAN International
                   Conference on Certified Programs and Proofs},
  pages =         {307--323},
  publisher =     {Association for Computing Machinery},
  series =        {CPP 2022},
  title =         {Implementing a category-theoretic framework for typed
                   abstract syntax},
  year =          {2022},
  abstract =      {In previous work ("From signatures to monads in
                   UniMath"),we described a category-theoretic
                   construction of abstract syntax from a signature,
                   mechanized in the UniMath library based on the Coq
                   proof assistant. In the present work, we describe
                   what was necessary to generalize that work to account
                   for simply-typed languages. First, some definitions
                   had to be generalized to account for the natural
                   appearance of non-endofunctors in the simply-typed
                   case. As it turns out, in many cases our mechanized
                   results carried over to the generalized definitions
                   without any code change. Second, an existing
                   mechanized library on ð-cocontinuous functors had
                   to be extended by constructions and theorems
                   necessary for constructing multi-sorted syntax.
                   Third, the theoretical framework for the semantical
                   signatures had to be generalized from a monoidal to a
                   bicategorical setting, again to account for
                   non-endofunctors arising in the typed case. This uses
                   actions of endofunctors on functors with given
                   source, and the corresponding notion of strong
                   functors between actions, all formalized in UniMath
                   using a recently developed library of bicategory
                   theory. We explain what needed to be done to plug all
                   of these ingredients together, modularly. The main
                   result of our work is a general construction that,
                   when fed with a signature for a simply-typed
                   language, returns an implementation of that language
                   together with suitable boilerplate code, in
                   particular, a certified monadic substitution
                   operation.},
  doi =           {10.1145/3497775.3503678},
  isbn =          {9781450391825},
  url =           {https://doi.org/10.1145/3497775.3503678},
}

@article{Allais2021,
  author =        {Allais, Guillaume and Atkey, Robert and
                   Chapman, James and McBride, Conor and McKinna, James},
  journal =       {Journal of Functional Programming},
  month =         oct,
  number =        {1996},
  pages =         {e22},
  title =         {A type- and scope-safe universe of syntaxes with
                   binding: their semantics and proofs},
  volume =        {31},
  year =          {2021},
  abstract =      {The syntax of almost every programming language
                   includes a notion of binder and corresponding bound
                   occurrences, along with the accompanying notions of
                   Î±-equivalence, capture-avoiding substitution, typing
                   contexts, runtime environments, and so on. In the
                   past, implementing and reasoning about programming
                   languages required careful handling to maintain the
                   correct behaviour of bound variables. Modern
                   programming languages include features that enable
                   constraints like scope safety to be expressed in
                   types. Nevertheless, the programmer is still forced
                   to write the same boilerplate over again for each new
                   implementation of a scope-safe operation (e.g.,
                   renaming, substitution, desugaring, printing), and
                   then again for correctness proofs. We present an
                   expressive universe of syntaxes with binding and
                   demonstrate how to (1) implement scope-safe
                   traversals once and for all by generic programming;
                   and (2) how to derive properties of these traversals
                   by generic proving. Our universe description, generic
                   traversals and proofs, and our examples have all been
                   formalised in Agda and are available in the
                   accompanying material available online at
                   https://github.com/gallais/generic-syntax .},
  doi =           {10.1017/S0956796820000076},
  issn =          {0956-7968},
  url =           {https://www.cambridge.org/core/product/identifier/
                  S0956796820000076/type/journal_article},
}

@unpublished{Aczel1978,
  author =        {Aczel, Peter},
  note =          {Unpublished note},
  title =         {A general {Church}--{Rosser} theorem},
  year =          {1978},
  url =           {http://www.ens-lyon.fr/LIP/REWRITING/MISC/AGeneralChurch-
                  RosserTheorem.pdf},
}

@inproceedings{Fiore1999,
  address =       {Trento, Italy},
  author =        {Fiore, Marcelo P. and Plotkin, Gordon D. and
                   Turi, Daniele},
  booktitle =     {Proceedings. 14th Symposium on Logic in Computer
                   Science},
  pages =         {193--202},
  publisher =     {IEEE},
  title =         {Abstract syntax and variable binding},
  year =          {1999},
  doi =           {10.1109/LICS.1999.782615},
  isbn =          {0-7695-0158-3},
  url =           {http://ieeexplore.ieee.org/lpdocs/epic03/wrapper.htm?
                  arnumber=782615},
}

@inproceedings{Arkor2020,
  address =       {New York, NY, USA},
  author =        {Arkor, Nathanael and Fiore, Marcelo},
  booktitle =     {Proceedings of the 35th Annual ACM/IEEE Symposium on
                   Logic in Computer Science},
  pages =         {88--101},
  publisher =     {Association for Computing Machinery},
  series =        {LICS '20},
  title =         {Algebraic models of simple type theories: A
                   polynomial approach},
  year =          {2020},
  abstract =      {We develop algebraic models of simple type theories,
                   laying out a framework that extends universal algebra
                   to incorporate both algebraic sorting and variable
                   binding. Examples of simple type theories include the
                   unityped and simply-typed Î»-calculi, the
                   computational Î»-calculus, and predicate logic.Simple
                   type theories are given models in presheaf
                   categories, with structure specified by algebras of
                   polynomial endofunctors that correspond to natural
                   deduction rules. Initial models, which we construct,
                   abstractly describe the syntax of simple type
                   theories. Taking substitution structure into
                   consideration, we further provide sound and complete
                   semantics in structured cartesian multicategories.
                   This development generalises Lambek's correspondence
                   between the simply-typed Î»-calculus and
                   cartesian-closed categories, to arbitrary simple type
                   theories.},
  doi =           {10.1145/3373718.3394771},
  isbn =          {9781450371049},
  url =           {https://doi.org/10.1145/3373718.3394771},
}

@phdthesis{Gast2004,
  author =        {Gast, Holger},
  school =        {Universit{\"a}t T{\"u}bingen},
  title =         {A generator for type checkers},
  year =          {2004},
  url =           {http://hdl.handle.net/10900/48845},
}

@inproceedings{Grewe2015,
  address =       {New York, NY, USA},
  author =        {Grewe, Sylvia and Erdweg, Sebastian and
                   Wittmann, Pascal and Mezini, Mira},
  booktitle =     {2015 ACM International Symposium on New Ideas, New
                   Paradigms, and Reflections on Programming and
                   Software (Onward!)},
  pages =         {137--150},
  publisher =     {Association for Computing Machinery},
  series =        {Onward! 2015},
  title =         {Type systems for the masses: {Deriving} soundness
                   proofs and efficient checkers},
  year =          {2015},
  abstract =      {The correct definition and implementation of
                   non-trivial type systems is difficult and requires
                   expert knowledge, which is not available to
                   developers of domain-specific languages (DSLs) in
                   practice. We propose Veritas, a workbench that
                   simplifies the development of sound type systems.
                   Veritas provides a single, high-level specification
                   language for type systems, from which it
                   automatically tries to derive soundness proofs and
                   efficient and correct type-checking algorithms. For
                   verification, Veritas combines off-the-shelf
                   automated first-order theorem provers with automated
                   proof strategies specific to type systems. For
                   deriving efficient type checkers, Veritas provides a
                   collection of optimization strategies whose
                   applicability to a given type system is checked
                   through verification on a case-by-case basis. We have
                   developed a prototypical implementation of Veritas
                   and used it to verify type soundness of the
                   simply-typed lambda calculus and of parts of typed
                   SQL. Our experience suggests that many of the
                   individual verification steps can be automated and,
                   in particular, that a high degree of automation is
                   possible for type systems of DSLs.},
  doi =           {10.1145/2814228.2814239},
  isbn =          {9781450336888},
  url =           {https://doi.org/10.1145/2814228.2814239},
}

@inproceedings{Fiore2010,
  address =       {Berlin, Heidelberg},
  author =        {Fiore, Marcelo and Hur, Chung-Kil},
  booktitle =     {Computer Science Logic. CSL 2010},
  editor =        {Dawar, Anuj and Veith, Helmut},
  pages =         {320--335},
  publisher =     {Springer Berlin Heidelberg},
  series =        {Lecture Notes in Computer Science},
  title =         {Second-order equational logic (Extended Abstract)},
  volume =        {6247},
  year =          {2010},
  abstract =      {We extend universal algebra and its equational logic
                   from first to second order as follows.},
  doi =           {10.1007/978-3-642-15205-4_26},
  isbn =          {978-3-642-15205-4},
}

@article{Ko2022,
  author =        {Ko, Hsiang-Shang and Chen, Liang-Ting and
                   Lin, Tzu-Chi},
  journal =       {Proceedings of the ACM on Programming Languages},
  number =        {ICFP},
  pages =         {1--29},
  title =         {Datatype-generic programming meets elaborator
                   reflection},
  volume =        {6},
  year =          {2022},
  doi =           {10.1145/3547629},
  url =           {https://doi.org/10.1145/3547629},
}

@inproceedings{Fiore2013,
  address =       {New Orleans, LA, USA},
  author =        {Fiore, Marcelo and Hamana, Makoto},
  booktitle =     {2013 28th Annual ACM/IEEE Symposium on Logic in
                   Computer Science},
  pages =         {520--529},
  publisher =     {IEEE},
  title =         {Multiversal polymorphic algebraic theories: Syntax,
                   semantics, translations, and equational Logic},
  year =          {2013},
  doi =           {10.1109/LICS.2013.59},
  isbn =          {978-1-4799-0413-6},
  issn =          {10436871},
}

@incollection{Hamana2011,
  address =       {Berlin, Heidelberg},
  author =        {Hamana, Makoto},
  booktitle =     {Foundations of Software Science and Computational
                   Structures. FoSSaCS 2011},
  editor =        {Hofmann, Martin},
  pages =         {381--395},
  publisher =     {Springer},
  series =        {Lecture Notes in Computer Science},
  title =         {Polymorphic abstract syntax via {Grothendieck}
                   construction},
  volume =        {6604},
  year =          {2011},
  doi =           {10.1007/978-3-642-19805-2_26},
}

@article{Cartmell1986,
  author =        {Cartmell, John},
  journal =       {Annals of Pure and Applied Logic},
  pages =         {209-243},
  title =         {Generalised algebraic theories and contextual
                   categories},
  volume =        {32},
  year =          {1986},
  doi =           {10.1016/0168-0072(86)90053-9},
  issn =          {0168-0072},
  url =           {https://www.sciencedirect.com/science/article/pii/
                  0168007286900539},
}

@article{Bezem2021,
  author =        {Bezem, Marc and Coquand, Thierry and Dybjer, Peter and
                   Escard{\'o}, Mart{\'\i}n H{\"o}tzel},
  journal =       {Mathematical Structures in Computer Science},
  month =         oct,
  number =        {9},
  pages =         {1--18},
  title =         {On generalized algebraic theories and categories with
                   families},
  volume =        {31},
  year =          {2021},
  abstract =      {We give a syntax independent formulation of finitely
                   presented generalized algebraic theories as initial
                   objects in categories of categories with families
                   (cwfs) with extra structure. To this end, we
                   simultaneously define the notion of a presentation Î£
                   of a generalized algebraic theory and the associated
                   category CwF Î£ of small cwfs with a Î£-structure and
                   cwf-morphisms that preserve Î£-structure on the nose.
                   Our definition refers to the purely semantic notion
                   of uniform family of contexts, types, and terms in
                   CwF Î£ . Furthermore, we show how to syntactically
                   construct an initial cwf with a Î£-structure. This
                   result can be viewed as a generalization of
                   Birkhoff's completeness theorem for equational logic.
                   It is obtained by extending Castellan, Clairambault,
                   and Dybjer's construction of an initial cwf. We
                   provide examples of generalized algebraic theories
                   for monoids, categories, categories with families,
                   and categories with families with extra structure for
                   some type formers of Martin-L{\"o}f type theory. The
                   models of these are internal monoids, internal
                   categories, and internal categories with families
                   (with extra structure) in a small category with
                   families. Finally, we show how to extend our
                   definition to some generalized algebraic theories
                   that are not finitely presented, such as the theory
                   of contextual cwfs.},
  doi =           {10.1017/S0960129521000268},
  issn =          {0960-1295},
  url =           {https://www.cambridge.org/core/product/identifier/
                  S0960129521000268/type/journal_article},
}

@phdthesis{Valliappan2023,
  address =       {Gothenburg, Sweden},
  author =        {Valliappan, Nachiappan},
  publisher =     {Chalmers},
  school =        {Department of Computer Science \& Engineering,
                   Chalmers University of Technology},
  title =         {Modular Normalization with Types},
  year =          {2023},
  isbn =          {978-91-7905-850-0},
  url =           {https://research.chalmers.se/en/publication/535726},
}

@article{Dybjer1994,
  author =        {Dybjer, Peter},
  journal =       {Formal Aspects of Computing},
  number =        {4},
  pages =         {440--465},
  title =         {Inductive families},
  volume =        {6},
  year =          {1994},
  abstract =      {A general formulation of inductive and recursive
                   definitions in Martin-L{\"o}f's type theory is
                   presented. It extends Backhouse's `Do-It-Yourself
                   Type Theory'to include inductive definitions of
                   families of sets and definitions of functions by
                   recursion on the way elements of such sets are
                   generated. The formulation is in natural deduction
                   and is intended to be a natural generalisation to
                   type theory of Martin-L{\"o}f's theory of iterated
                   inductive definitions in predicate logic.},
  doi =           {10.1007/BF01211308},
  isbn =          {1433-299X},
  url =           {https://doi.org/10.1007/BF01211308},
}
  
