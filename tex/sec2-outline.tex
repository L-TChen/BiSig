%!TEX root = BiSig.tex

\section{Bidirectional Type Synthesis for Simply Typed \texorpdfstring{$\lambda$}{Î»}-Calculus} \label{sec:key-ideas}

\begin{figure}
  \small
  \bgroup
  \renewcommand{\arraystretch}{1.5}
  \begin{tabular}{ r l }
    $\boxed{V |- \isTerm{t}}$ & Given a list~$V$ of variables, $t$~is a raw term with free variables in~$V$
  \end{tabular}
  \egroup
  \centering
  \begin{mathpar}
    \inferrule{x \in V}{V \vdash \isTerm{x}}\,\Rule{Var}
    \and
    \inferrule{V \vdash \isTerm{t}}{V \vdash \isTerm{(t \annotate A)}}\,\Rule{Anno}
    \and
    \inferrule{V, \isTerm{x} \vdash \isTerm{t}}{V \vdash \isTerm{\lam{x}t}}\,\Rule{Abs}
    \and
    \inferrule{V \vdash \isTerm{t} \\ V \vdash \isTerm{u}}{V \vdash \isTerm{t\;u}}\,\Rule{App}
  \end{mathpar}
  \caption{Raw terms for simply typed $\lambda$-calculus}
  \label{fig:STLC-raw-terms}
\end{figure}

\begin{figure}
  \small
  \bgroup
  \renewcommand{\arraystretch}{1.5}
  \begin{tabular}{ r l }
    $\boxed{\Gamma |- \isTerm{t} : A}$ & A raw term~$t$ has type~$A$ under context~$\Gamma$
  \end{tabular}
  \egroup
  \centering
  \begin{mathpar}
    \inferrule{(x : A) \in \Gamma}{\Gamma \vdash \isTerm{x} : A}\,\Rule{Var}
    \and
    \inferrule{\Gamma \vdash \isTerm{t} : A}{\Gamma \vdash \isTerm{(t \annotate A)} : A}\,\Rule{Anno}
    \and
    \inferrule{\Gamma, \isTerm{x} : A \vdash \isTerm{t} : B}{\Gamma \vdash \isTerm{\lam{x}t} : A \bto B}\,\Rule{Abs}
    \and
    \inferrule{\Gamma \vdash \isTerm{t} : A \bto B \\ \Gamma \vdash \isTerm{u} : A}{\Gamma \vdash \isTerm{t\;u} : B}\,\Rule{App}
  \end{mathpar}
  \caption{Typing derivations for simply typed $\lambda$-calculus}
  \label{fig:STLC-typing-derivations}
\end{figure}

We start with an overview of our theory by instantiating it to simply typed $\lambda$-calculus.
Roughly speaking, the problem of type synthesis requires us to take an untyped abstract syntax tree ---which we call a \emph{raw term}--- as input, and produce a typing derivation for the term if possible.
To give more precise definitions:
The raw terms%
\footnote{We omit the usual conditions about named representations of variables throughout this paper.}
for simply typed $\lambda$-calculus are defined in \cref{fig:STLC-raw-terms};
besides the standard constructs, there is an \textsc{Anno} rule that allows the user to insert type annotations to help with type synthesis.
Correspondingly, the definition of typing derivations%
\footnote{We write~`$\bto$' instead of~`$\to$' for the function types of simply typed $\lambda$-calculus to avoid confusion with the function types in our type-theoretic meta-language.}
in \cref{fig:STLC-typing-derivations} also includes an \textsc{Anno} rule enforcing that the type of an annotated term does match the annotation.
%\footnote{The presence of type annotations allows type synthesis to subsume type checking: to check whether a term~$t$ has type~$A$, synthesise the type of $t \bbcolon A$.}
Now we can define what it means to solve the type synthesis problem.

\begin{definition}
\label{def:STLC-type-synthesiser}
Parametrised by an `excuse' predicate~$E$ on raw terms, a \emph{type synthesiser} takes a context~$\Gamma$ and a raw term $|\Gamma| \vdash t$ (where $|\Gamma|$~is the list of variables appearing in~$\Gamma$) as input, and establishes one of the following outcomes:
\begin{enumerate}
\item there exists a derivation of $\Gamma \vdash t : A$ for some type~$A$,
\item there does not exist a derivation $\Gamma \vdash t : A$ for any type~$A$, or
\item $E$~holds for~$t$.
\end{enumerate}
\end{definition}

It is crucial to allow the third outcome, without which we would be requiring the type synthesis problem to be decidable, but this requirement would quickly become impossible to meet when the theory is extended to handle more complex types.
If a type synthesiser cannot decide whether there is a typing derivation, it is allowed to give an excuse instead of an answer.
Acceptable excuses are defined by the predicate~$E$, which describes what is wrong with an input term, for example not having enough type annotations.

\begin{figure}
  \small
  \bgroup
  \renewcommand{\arraystretch}{1.5}
  \begin{tabular}{ r l }
    $\boxed{\Gamma |- \isTerm{t} \syn A}$ & A raw term $t$ synthesises a type $A$ under $\Gamma$ \\
    $\boxed{\Gamma |- \isTerm{t} \chk A}$ &A raw term $t$ checks against a type $A$ under $\Gamma$
  \end{tabular}
  \egroup
  \centering
  \begin{mathpar}
    \inferrule{(\isTerm{x} : A) \in \Gamma}{\Gamma \vdash \isTerm{x} \syn A}\,\SynRule{Var}
    \and
    \inferrule{\Gamma \vdash \isTerm{t} \chk A}{\Gamma \vdash \isTerm{(t \annotate A)}\syn A}\,\SynRule{Anno}
    \and
    \inferrule{\Gamma \vdash \isTerm{t} \syn A \\ A = B}{\Gamma \vdash \isTerm{t} \chk B}\,\ChkRule{Sub}
    \and
    \inferrule{\Gamma, \isTerm{x} : A \vdash \isTerm{t} \chk B}{\Gamma \vdash \isTerm{\lam{x}t} \chk A \bto B}\,\ChkRule{Abs}
    \and
    \inferrule{\Gamma \vdash \isTerm{t} \syn A \bto B \\ \Gamma \vdash \isTerm{u} \chk A}{\Gamma \vdash \isTerm{t\;u} \syn B}\,\SynRule{App}
  \end{mathpar}
  \caption{Bidirectional typing derivations for simply typed $\lambda$-calculus}
  \label{fig:STLC-bidirectional-typing-derivations}
\end{figure}

Now our goal is to use \cref{def:STLC-type-synthesiser} as a specification and implement it using a \emph{bidirectional} type synthesiser, which attempts to produce \emph{bidirectional} typing derivations defined in \cref{fig:STLC-bidirectional-typing-derivations}.
Here we briefly recap the basic ideas of bidirectional type synthesis.
While the problem of type synthesis is not decidable in general, for certain kinds of terms it is still possible to synthesise their types --- for example, the $\SynRule{Var}$ rule says that the type of a variable can be looked up in the context.
For other kinds of terms, we can switch to the simpler problem of type \emph{checking}, where the expected type of a term is given as input so that there is more information to work with.
When a bidirectional type synthesiser traverses a raw term, it switches between the two \emph{modes}, synthesising wherever possible, and checking otherwise.
If a bidirectional type system is designed well (i.e.~\emph{mode-correct}, which will be defined in \cref{sec:type-synthesis}), then there will be a flow of type information in each rule that allows us to determine unknown types (e.g.~types to be checked) from known ones (e.g.~types previously synthesised), and suggests how bidirectional type synthesis is performed --- for example, the $\SynRule{App}$ rule says that to synthesise the type of an application $\isTerm{t\;u}$, we first synthesise the type of~$\isTerm{t}$, which should have the form $A \bto B$, from which we can extract the expected type of~$\isTerm{u}$, namely~$A$, and perform checking; then the type of the whole application, namely~$B$, can also be extracted from the previously synthesised type $A \bto B$.

%The $\ChkRule{Abs}$ rule checks whether the type of an abstraction $\isTerm{\lam{x}t}$ is $A \bto B$ by checking whether $\isTerm{t}$~has type~$B$ assuming $\isTerm{x}$~has type~$A$ in the context, where both types $A$~and~$B$ can be determined from the type $A \bto B$ given initially.
%For an annotated term $t \bbcolon A$, the $\SynRule{Anno}$ rule simply synthesises~$A$ as its type, provided that $t$~can be successfully checked to have type~$A$.
%Finally, the subsumption rule $\ChkRule{Sub}$ says that a term synthesising a type~$A$ can be checked to have type~$B$ if $A = B$ --- in general this type equality can be replaced by some subtyping relation.

\begin{figure}
  \centering
  \small
  \judgbox{|- \isTerm{t}^\dir{d}}{A raw term~$\isTerm{t}$ is in mode~$d$}
  \begin{mathpar}
    \inferrule{x \in V}{V |- \isTerm{x}^{\syn}}\,\SynRule{Var}
    \and
    \inferrule{V |- \isTerm{t}^{\chk}}{V |- (\isTerm{t \annotate A})^{\syn}}\,\SynRule{Anno}
    \and
    \inferrule{V |- \isTerm{t}^{\syn}}{V |- \isTerm{t}^{\chk}}\,\ChkRule{Sub}
    \\
    \inferrule{V, x |- \isTerm{t}^{\chk}}
    {V |- (\isTerm{\lam{x}t})^{\chk}}\,\ChkRule{Abs}
    \and
    \inferrule{V |- \isTerm{t}^{\syn} \\ V |- \isTerm{u}^{\chk}}
    {V |- (\isTerm{t\;u})^{\syn}}\,\SynRule{App}
  \end{mathpar}
  \caption{Mode derivations for simply typed $\lambda$-calculus}
  \label{fig:STLC-mode-derivations}
\end{figure}

While it is possible for a bidirectional type synthesiser to do its job in one go, which can be thought of as adding both mode and typing information to a raw term and arriving at a bidirectional typing derivation, it is beneficial to have a preprocessing step which adds only mode information, based on which the synthesiser then continues to add typing information.
More precisely, the preprocessing step attempts to produce \emph{mode derivations} as defined in \cref{fig:STLC-mode-derivations}, where the rules are exactly the mode part of the bidirectional typing rules~(\cref{fig:STLC-bidirectional-typing-derivations}).

\begin{definition}
\label{def:STLC-mode-preprocessor}
A \emph{mode preprocessor} decides for any raw term~$V \vdash \isTerm{t}$ and mode~$\dir{d}$ whether $V \vdash \isTerm{t}^\dir{d}$.
\end{definition}

One (smaller) benefit of mode preprocessing is that it helps to simplify the synthesiser, whose computation can be partly directed by a mode derivation.
More importantly, whether there is a mode derivation for a term is actually very useful information to the user, because it corresponds to whether the term has enough type annotations:
Observe that the $\SynRule{Anno}$ and $\ChkRule{Sub}$ rules allow us to switch between the synthesising and checking modes;
the switch from synthesising to checking is free, whereas the opposite direction requires a type annotation.
That is, any term in synthesising mode is also in checking mode, but not necessarily vice versa.
A type annotation is required wherever a term that can only be in checking mode is required to be in synthesising mode, and a term does not have a mode derivation if and only if type annotations are missing in such places.
(We will treat all these more rigorously in \cref{sec:pre-synthesis}.)
For example, an abstraction is strictly in checking mode, but the left sub-term of an application has to be synthesising, so the term $\isTerm{(\lam{x}t)\;u}$ does not have a mode derivation unless we annotate the abstraction.

Perhaps most importantly, mode derivations enable us to give bidirectional type synthesisers a tight definition: if we restrict the domain of a synthesiser to terms in synthesising mode (i.e.~having enough type annotations for performing synthesis), then it is possible for the synthesiser to \emph{decide} whether there is a suitable typing derivation.

\begin{definition}
\label{def:STLC-bidirectional-type-synthesiser}
A \emph{bidirectional type synthesiser} decides for any context~$\Gamma$ and synthesising term $|\Gamma| \vdash \isTerm{t}^{\syn}$ whether $\Gamma \vdash \isTerm{t} \syn A$ for some type~$A$.
\end{definition}

Now we can get back to our goal of implementing a type synthesiser~(\cref{def:STLC-type-synthesiser}).

\begin{theorem}
A type synthesiser that uses `not in synthesising mode' as its excuse can be constructed from a mode preprocessor and a bidirectional type synthesiser.
\end{theorem}

The construction is straightforward:
Run the mode preprocessor on the input term~$|\Gamma| \vdash t$.
If there is no synthesising mode derivation, report that $t$~is not in synthesising mode (the third outcome).
Otherwise $|\Gamma| \vdash t^{\syn}$, and we can run the bidirectional type synthesiser.
If it finds a derivation of $\Gamma \vdash t \syn A$ for some type~$A$, return a derivation of $\Gamma \vdash t : A$ (the first outcome), which is possible because the bidirectional typing~(\cref{fig:STLC-bidirectional-typing-derivations}) is \emph{sound} with respect to the original typing~(\cref{fig:STLC-typing-derivations}).

\begin{lemma}[Soundness]
If\/ $\Gamma \vdash t :^\dir{d} A$, then $\Gamma \vdash t : A$.
\end{lemma}

If there is no derivation of $\Gamma \vdash t \syn A$ for any type~$A$, report that there is no derivation of $\Gamma \vdash t : A$ for any~$A$ either (the second outcome), because the bidirectional typing is \emph{complete} with respect to the original typing.

\begin{lemma}[Completeness]
If\/ $|\Gamma| \vdash t^\dir{d}$ and\/ $\Gamma \vdash t : A$, then $\Gamma \vdash t :^\dir{d} A$.
\end{lemma}

We will construct a mode preprocessor~(\cref{sec:mode-preprocessing}) and a bidirectional type synthesiser~(\cref{sec:type-synthesis}) and prove both lemmas~(\cref{sec:soundness-and-completeness}) for all syntax-directed bidirectional simple type systems.
To quantify over all such systems, we need their generic definitions, which we formulate in \cref{sec:defs}.
