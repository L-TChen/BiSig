%!TEX root = BiSig.tex

\section{Bidirectional Type Synthesis for Simply Typed \texorpdfstring{$\lambda$}{λ}-Calculus} \label{sec:key-ideas}

\begin{figure}
  \small
  \bgroup
  \renewcommand{\arraystretch}{1.5}
  \begin{tabular}{ r l }
    $\boxed{\Gamma' |- \isTerm{t}}$ & Given a list~$\Gamma'$ of variables, $t$~is a raw term with free variables in~$\Gamma'$
  \end{tabular}
  \egroup
  \centering
  \begin{mathpar}
    \inferrule{x \in \Gamma'}{\Gamma' \vdash \isTerm{x}}\,\Rule{Var}
    \and
    \inferrule{\Gamma' \vdash \isTerm{t} \\ \isTerm{A}\text{ is a closed type}}{\Gamma' \vdash \isTerm{(t \annotate A)}}\,\Rule{Anno}
    \and
    \inferrule{\Gamma', \isTerm{x} \vdash \isTerm{t}}{\Gamma' \vdash \isTerm{\lam{x}t}}\,\Rule{Abs}
    \and
    \inferrule{\Gamma' \vdash \isTerm{t} \\ \Gamma' \vdash \isTerm{u}}{\Gamma' \vdash \isTerm{t\;u}}\,\Rule{App}
  \end{mathpar}
  \caption{Raw terms for simply typed $\lambda$-calculus}
  \label{fig:STLC-raw-terms}
\end{figure}

\begin{figure}
  \small
  \bgroup
  \renewcommand{\arraystretch}{1.5}
  \begin{tabular}{ r l }
    $\boxed{\Gamma |- \isTerm{t} : A}$ & A raw term~$t$ has type~$A$ under context~$\Gamma$
  \end{tabular}
  \egroup
  \centering
  \begin{mathpar}
    \inferrule{(x : A) \in \Gamma}{\Gamma \vdash \isTerm{x} : A}\,\Rule{Var}
    \and
    \inferrule{\Gamma \vdash \isTerm{t} : A}{\Gamma \vdash \isTerm{(t \annotate A)} : A}\,\Rule{Anno}
    \and
    \inferrule{\Gamma, \isTerm{x} : A \vdash \isTerm{t} : B}{\Gamma \vdash \isTerm{\lam{x}t} : A \bto B}\,\Rule{Abs}
    \and
    \inferrule{\Gamma \vdash \isTerm{t} : A \bto B \\ \Gamma \vdash \isTerm{u} : A}{\Gamma \vdash \isTerm{t\;u} : B}\,\Rule{App}
  \end{mathpar}
  \caption{Typing derivations for simply typed $\lambda$-calculus}
  \label{fig:STLC-typing-derivations}
\end{figure}

To start off, we give an overview of our theory by instantiating it to simply typed $\lambda$-calculus~($\Lambda_{\bto}$).
Roughly speaking, the problem of type synthesis requires us to take an untyped abstract syntax tree ---which we call a \emph{raw term}--- as input, and produce a typing derivation for the term if possible.
To give more precise definitions:
The raw terms for~$\Lambda_{\bto}$ are defined in \cref{fig:STLC-raw-terms}; besides the standard constructs, there is an \textsc{Anno} rule that allows the user to insert type annotations to help with type synthesis.
Correspondingly, the definition of typing derivations for~$\Lambda_{\bto}$ in \cref{fig:STLC-typing-derivations} also includes an \textsc{Anno} rule enforcing that the type of an annotated term does match the annotation.
Now we can define what it means to solve the type synthesis problem.

\begin{definition}
\label{def:STLC-type-synthesisers}
Parametrised by a (possibly proof-relevant) predicate~$E$ on raw terms, a \emph{type synthesiser} (for $\Lambda_{\bto}$) takes a context~$\Gamma$ and a raw term $\Gamma' \vdash t$ (where $\Gamma'$~is the list of variables appearing in~$\Gamma$) as input, and establishes one of the following outcomes:
\begin{enumerate}
\item a derivation of $\Gamma \vdash t : A$ for some type~$A$,
\item there does not exist a derivation $\Gamma \vdash t : A$ for any type~$A$, or
\item $E$~holds for~$t$.
\end{enumerate}
\end{definition}

It is crucial to allow the third outcome, without which we would be requiring the type synthesis problem to be decidable, but this requirement would quickly become impossible to meet when the theory is extended to handle more complex types.
If a type synthesiser cannot decide whether there is a typing derivation, it is allowed to give an `excuse' instead of an answer.
Acceptable excuses are captured by the predicate~$E$, which describes what is wrong with an input term, for example not having enough type annotations.

\begin{figure}
  \small
  \bgroup
  \renewcommand{\arraystretch}{1.5}
  \begin{tabular}{ r l }
    $\boxed{\Gamma |- \isTerm{t} \syn A}$ & A raw term $t$ synthesises a type $A$ under $\Gamma$ \\
    $\boxed{\Gamma |- \isTerm{t} \chk A}$ &A raw term $t$ checks against a type $A$ under $\Gamma$
  \end{tabular}
  \egroup
  \centering
  \begin{mathpar}
    \inferrule{(\isTerm{x} : A) \in \Gamma}{\Gamma \vdash \isTerm{x} \syn A}\,\SynRule{Var}
    \and
    \inferrule{\Gamma \vdash \isTerm{t} \chk A}{\Gamma \vdash \isTerm{(t \annotate A)}\syn A}\,\SynRule{Anno}
    \and
    \inferrule{\Gamma \vdash \isTerm{t} \syn B \\ B = A}{\Gamma \vdash \isTerm{t} \chk A}\,\ChkRule{Sub}
    \and
    \inferrule{\Gamma, \isTerm{x} : A \vdash \isTerm{t} \chk B}{\Gamma \vdash \isTerm{\lam{x}t} \chk A \bto B}\,\ChkRule{Abs}
    \and
    \inferrule{\Gamma \vdash \isTerm{t} \syn A \bto B \\ \Gamma \vdash \isTerm{u} \chk A}{\Gamma \vdash \isTerm{t\;u} \syn B}\,\SynRule{App}
  \end{mathpar}
  \caption{Bidirectional typing derivations for simply typed $\lambda$-calculus}
  \label{fig:STLC-bidirectional-typing-derivations}
\end{figure}

Now our goal is to use \cref{def:STLC-type-synthesisers} as a specification and implement it using a \emph{bidirectional} type synthesiser, which attempts to produce \emph{bidirectional} typing derivations defined in \cref{fig:STLC-bidirectional-typing-derivations}.
While type synthesis is not decidable in general, for certain kinds of terms it is still possible to synthesise their types (for example, the type of a variable can be looked up in the context), and for other kinds of terms we can switch to the simpler problem of type \emph{checking}, where the expected type of a term is also given so that the type checker has more information to work with.
If a bidirectional type system is designed well, then synthesised type information will be enough for figuring out the expected types for checking.

\begin{remark}
  We avoid using the term `function type' and its conventional notation $\to$ at the object level on purpose, as it may be confused with function types in our type-theoretic meta-language.
\end{remark}

\Josh{

• Figures: raw terms, standard typing, bidirectional typing, and mode derivations ($\frac{2}{3}$~pages)

• Bidirectional typing (general idea and specific STLC rules); the goal is to implement a type synthesiser using a bidirectional one

• Beneficial to separate \emph{bidirectionalisation} from type synthesis (syntactic characterisation of the domain of type synthesis; making type synthesisers syntax- (or more precisely, derivation-) directed)

• Definitions of mode derivations, bidirectionalisers, and bidirectional type synthesisers

• Back to the goal; soundness and completeness ($1\frac{1}{2}$~pages)
}
