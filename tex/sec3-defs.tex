%!TEX root = BiSig.tex

\section{Simple Typed Languages and Bidirectional Type Systems}\label{sec:defs}
This section provides generic definitions
%\footnote{%
%Here's the 'small print': Our definitions cover typical examples and set the scope for bidirectional simple type systems discussed, but do not offer comprehensive coverage of all possibilities.}
of simple types, simply typed languages, and bidirectional type systems, using simply typed $\lambda$-calculus in \cref{sec:key-ideas} as our running example.
All these definitions are inductive, which we will not emphasise in the individual definitions.

Our definitions are formulated in two steps:
\begin{enumerate*}
  \item we first introduce a notion of signature which includes a set of operation symbols and an assignment of \emph{arities} to each operation;
\item then, we define abstract syntax trees inductively with primitive constructs such as $\Rule{Var}$ and constructs specified by a given signature.
\end{enumerate*}
Upon moving from simple types to bidirectionally typed terms, the notion of arity, initially as the number of arguments of an operation, is enriched to incorporate an extension context for variable binding and the direction of type information flow.

\subsection{Signatures and Simple Types} \label{subsec:simple-types}
Simple types are understood intuitively as a collection of types whose formation judgement is not indexed by anything but a fixed set of type variables, and the only datum needed for specifying a type construct is its number of arguments:

\begin{definition} \label{def:simple-signature}
%  \begin{figure}
%%    \begin{minipage}[b]{.6\textwidth}
%      \centering
%      \small
%      \judgbox{\Xi|-_{\Sigma} A}{$A$ is a well-formed type with type variables in $\Xi$}
%      \begin{mathpar}
%        \inferrule{\Xi \ni X_i}{\Xi |-_\Sigma X_i} \and
%        \inferrule{\Xi |-_{\Sigma} A_1 \\ \cdots \\ \Xi |-_{\Sigma} A_n}{\Xi |-_{\Sigma} \tyOp_i(A_1, \ldots, A_n)}\;\text{where $n = \arity(i)$}
%      \end{mathpar}
%      \caption{Simple types}
%      \label{fig:simple-type}
%%    \end{minipage}
%%    \begin{minipage}[b]{.35\textwidth}
%%      \centering
%%      \small
%%      \judgbox{\Xi |-_{\Sigma} \Gamma}{}
%%      \begin{mathpar}
%%        \inferrule{ }{\Xi |-_{\Sigma} \cdot }\and
%%        \inferrule{\Xi |-_{\Sigma} A \\ \Xi|-_{\Sigma} \Gamma}{\Xi |-_{\Sigma} \Gamma, x : A}
%%      \end{mathpar}
%%      \caption{Contexts}
%%    \label{fig:simple-context}
%%    \end{minipage}
%  \end{figure}
  A \emph{signature} $\Sigma$ for simple types consists of a set\footnote{%
    Even though our theory is developed in Martin-L\"of type theory, the term `set' is used instead of `type' to avoid the obvious confusion. 
    Also, as we assume \AxiomK, all types are legitimate sets in the sense of homotopy type theory.
  }
  $I$ with a decidable equality and an \emph{arity} function $\arity\colon I \to \mathbb{N}$.
  For a signature $\Sigma$, a \emph{type} $A : \Type_{\Sigma}(\Xi)$ over a variable set $\Xi$ is either
  \begin{enumerate}
    \item a variable in $\Xi$ or
    \item $\tyOp_{i}(A_1, \ldots, A_n)$ for some $i:I$ with $\arity(i) = n$ and types $A_1,\ldots, A_n$.
  \end{enumerate}
  %as defined in \Cref{fig:simple-type}.
  A \emph{context} $\Gamma \colon \Cxt_{\Sigma}(\Xi)$ over $\Xi$ is a list $\Gamma$ of types over $\Xi$. 
\end{definition}

\begin{example} \label{ex:type-signature-for-function-type}
  Simply typed $\lambda$-calculus includes function types $A \bto B$ and typically a base type~$\mathtt{b}$ to ensure that the set of all types without type variables is non-empty.
  The type signature $\Sigma_{\bto}$ used to define types in simply typed $\lambda$-calculus consists of a binary operation $\mathsf{fun}$ and a nullary operation $\mathsf{b}$ where $\arity(\mathsf{fun}) = 2$ and $\arity(\mathsf{b}) = 0$.
  Then, all types in simply typed $\lambda$-calculus can be given as $\Sigma_{\bto}$-types over the empty set with $A \bto B$ introduced as $\tyOp_{\mathsf{fun}}(A, B)$ and $\mathtt{b}$ as $\tyOp_{\mathsf{b}}$. 
\end{example}

As \Cref{def:simple-signature} includes type variables, we introduce the typical meta-operation: substitution.
\begin{definition}
  The \emph{substitution} for a function $\rho\colon \Xi to \Type_{\Sigma}(\Xi')$, denoted by $\rho\colon \Sub{\Xi}{\Xi'}$, is a map which sends a type $A$ of $\Type_{\Sigma}(\Xi)$ to $\simsub{A}{\rho}$ of $\Type_{\Sigma}(\Xi')$ and is defined as usual.
  By abuse of notation, the substitution $\simsub{\Gamma}{\rho}$ of a context $\Gamma$ is defined by applying substitution to each $A$ in $\Gamma$.
\end{definition}

We may confine the use of an arbitrary variable set $\Xi$ to some set in the family of sets $\Fin(n)$ of natural numbers less than $n$, as defined by \citet{Dybjer1994}, for the following reasons.
In bidirectional type synthesis, a decidable equality on $\Type_{\Sigma}(\Xi)$ is necessary, as we need to compare the synthesised type $B$ with a given type $A$ for the $\Rule{Sub}$ rule.
If $\Xi$ has a decidable equality as $\Fin(n)$ does, then $\Type_{\Sigma}(\Xi)$ also has a decidable equality.
In addition, the arity of a construct is finite, so it suffices to use natural numbers to denote type variables in a type.
As we will only consider a finite collection of types (in a typing rule or in a signature), we can formally restrict the set $\Xi$ to the family of $\Fin(n)$ in later definitions.
For illustrative purposes, though, we still use named variables for presentation.
\subsection{Binding Signatures and Simple Typed Languages} \label{subsec:binding-sig}

A simple typed language consists of
\begin{enumerate*}
  \item a set of raw terms $\isTerm{t}$ indexed by a set $V$ of untyped variables where each construct is allowed to bind some variables like $\Rule{Abs}$ and to take multiple arguments like $\Rule{App}$;
  \item a set of typing derivations indexed by a list $\Gamma$ of typed variables, a type~$A$, and a raw term $\isTerm{t}$ to set their type constraints. 
\end{enumerate*}
Therefore, to specify a term construct, we enrich the notion of arity with sorts and extension context for variable binding:
\begin{definition}\label{def:binding-arity}
  A \emph{binding arity} with a sort $T$ is an inhabitant of $\left(T^* \times T\right)^* \times T$ where $T^*$ is the set of lists over $T$.
  In a binding arity ${[\Delta_1]A_{1}, \ldots, \left[\Delta_{n}\right] A_{n}} \to {A_0}$, every $\Delta_i$ and $A_i$ refers to the \emph{extension context} and the sort of the $i$-th argument, respectively; for brevity, we denote it as ${[\Delta_1]A_{1}, \ldots, \left[\Delta_{n}\right] A_{n}} \to {A_0}$ and omit $[\Delta_i]$ if $\Delta_i$ is empty.
\end{definition}

For example, the $\Rule{Abs}$ rule (\Cref{fig:STLC-typing-derivations}) has the binding arity with $T = \Type_{\Sigma}(\{A, B\})$:
\[
  {[A]B} \to {(A \bto B)}
\]
indicating that the $\Rule{Abs}$ rule for an abstraction $\lam{x}t$ has
\begin{enumerate*}
  \item an argument (i.e.\ a typing derivation of $\Gamma, x : A |- t : B$) of type $B$ in a context extended by a variable $x$ of type $A$;
  \item the type $A\bto B$ for the conclusion $\Gamma |- \lam{x}t : A \bto B$ itself.
\end{enumerate*}
Similarly, the arity of the $\Rule{App}$ rule for an application $t\;u$ is ${(A \bto B), A} \to {B}$, indicating that it takes two arguments (i.e.\ typing derivations for $t$ and $u$) of types $A \bto B$ and $A$, respectively, with their extension contexts empty and the resulting type is $B$.

Next, akin to a signature, our binding signature $\Omega$ consists of a set of operation symbols along with their respective binding arities.
It also includes additionally the number $\Xi$ of type variables that appear in the binding arity with the sort $\Type_{\Sigma}(\Xi)$ for each operation:
\begin{definition}\label{def:binding-signature}
  For a type signature $\Sigma$, a \emph{binding signature} $\Omega$ consists of a set $O$ and a function
  \[
    \arity(o) \colon O \to \sm{\Xi : \N} \left(\Cxt_\Sigma(\Xi) \times \Type_\Sigma(\Xi)\right)^* \times \Type_\Sigma(\Xi).
  \]
\end{definition}
Each inhabitant $o: O$ is meant to represent a term construct except the rules $\Rule{Var}$ and $\Rule{Anno}$ in a simply typed language and is associated with a number $\Xi$ of type variables and a binding arity with sort $\Type_{\Sigma}(\Xi)$.
As we will always consider binding arities with a number of type variables that appear in a typing rule, we simply call $\arity(o)$ the arity of $o$, denoted by $\aritysymbol{o}{\Xi}{[\Delta_1]A_1, \ldots, [\Delta_{n}]A_{n}}{A_0}$.
By a \emph{simply typed language} $(\Sigma, \Omega)$, we mean a pair of a type signature $\Sigma$ and a binding signature $\Omega$.

\begin{definition}
\begin{figure}
  \centering
  \small
  \judgbox{V |-_{\Sigma, \Omega} \isTerm{t}}{Given a list~$V$ of variables, $\isTerm{t}$ is a raw term for the signature $(\Sigma, \Omega)$ with free variables in~$V$}
  \begin{mathpar}
    \inferrule{\isTerm{x} \in V}{V |-_{\Sigma, \Omega} \isTerm{x}}\,\Rule{Var}
    \and
    \inferrule{\cdot |-_{\Sigma} A \\ V |-_{\Sigma, \Omega}\isTerm{t}}{V |-_{\Sigma, \Omega} \isTerm{t \annotate A}}\,\Rule{Anno}
    \\
    \inferrule{V, \vars{x}_\isTerm{1} |-_{\Sigma, \Omega} \isTerm{t_1} \\ \cdots \\ V, \vars{x}_\isTerm{n} |-_{\Sigma, \Omega} \isTerm{t_n} } {V |-_{\Sigma, \Omega} \tmOpts }\,\Rule{Op} \and
    \text{for $\aritysymbol{o}{\Xi}{[\Delta_1]A_{1}, \ldots, [\Delta_{n}] A_{n}}{A_0}$ in $\Omega$}
  \end{mathpar}
  \caption{Raw terms}
  \label{fig:raw-terms}
\end{figure}
  For a simply typed language $(\Sigma, \Omega)$, the set of \emph{raw terms} indexed by a context~$V$ of free variables consists of
  \begin{enumerate}
    \item variables in $V$,
    \item annotations $\isTerm{t \annotate A}$ for some raw term $t$ in $V$ and a type $A$, and
    \item a construct $\tmOpts$ for some $\aritysymbol{o}{\Xi}{[\Delta_1]A_{1}, \ldots, [\Delta_{n}] A_{n}}{A_0}$ in $O$, where $\vars{x}_{\isTerm{i}}$'s are lists of variables whose length is equal to the length of~$\Delta_i$ and $t_i$'s are raw terms in the variable list $V, \vars{x}_i$
  \end{enumerate}
  corresponding to rules $\Rule{Var}$, $\Rule{Anno}$, and $\Rule{Op}$ in \Cref{fig:raw-terms} respectively.
\end{definition}


The definition of typing derivations is a bit more involved.
We need some information to compare types on the object level during type synthesis and substitute those type variables in a typing derivation $\Gamma \vdash \tmOpts : A$ for an operation $o$ in $\Omega$ at some point.
Hence we choose to include a substitution as part of its typing derivation explicitly:
\begin{definition}\label{def:typing-derivations}
  \begin{figure}
    \centering
    \small
    \judgbox{\Gamma |-_{\Sigma, \Omega} \isTerm{t} : A}{A raw term $\isTerm{t}$ has a type $A$ without type variables under $\Gamma$ for the signature $(\Sigma, \Omega)$}
    \begin{mathpar}
      \inferrule{(\isTerm{x} : A) \in \Gamma}{\Gamma |-_{\Sigma, \Omega} \isTerm{x} : A}\,\Rule{Var}
      \and
      \inferrule{\Gamma |-_{\Sigma, \Omega} \isTerm{t} : A}{\Gamma |-_{\Sigma, \Omega} (\isTerm{t \annotate A}) : A}\,\Rule{Anno}
      \and
      \inferrule{\rho : \Sub{\Xi}{\emptyset} \\  \Gamma, \vec{\isTerm{x}}_\isTerm{1} : \simsub{\Delta_{1}}{\rho} |-_{\Sigma, \Omega} \isTerm{t_1} : \simsub{A_{1}}{\rho} \quad\cdots\quad \Gamma, \vec{\isTerm{x}}_\isTerm{n} : \simsub{\Delta_{n}}{\rho} |-_{\Sigma, \Omega} \isTerm{t_n} : \simsub{A_{n}}{\rho}}
      {\Gamma |-_{\Sigma, \Omega} \tmOpts : \simsub{A_0}{\rho}}\,\Rule{Op}
      \\
    \text{for $\aritysymbol{o}{\Xi}{[\Delta_1]A_{1}, \ldots, [\Delta_{n}] A_{n}}{A_0}$ in $\Omega$}
    \end{mathpar}
    \caption{Typing derivations}
    \label{fig:extrinsic-typing}
  \end{figure}
  For a simply typed language $(\Sigma, \Omega)$, the set of \emph{typing derivations} of $\Gamma \vdash \isTerm{t} : A$ indexed by a context $\Gamma$, a raw term with free variables in $\erase{\Gamma}$, and a type $A$ consists of 
  \begin{enumerate}
    \item a derivation of $\Gamma |-_{\Sigma, \Omega} x : A$ if $x : A$ is in $\Gamma$,
    \item a derivation of $\Gamma |-_{\Sigma, \Omega} (t \annotate A) : A$ if $\Gamma \vdash_{\Sigma, \Omega} \isTerm{t} : A$ has a derivation, and
    \item a derivation of $\Gamma |-_{\Sigma, \Omega} \tmOpts : \simsub{A_0}{\rho}$ for $\aritysymbol{o}{\Xi}{[\Delta_1]A_1, \ldots, [\Delta_{n}]A_{n}}{A_0}$ if there is a function $\rho\colon \Xi \to \Type_{\Sigma}(\emptyset)$ and a derivation of $\Gamma, \vars{x}_{\isTerm{i}} : \Delta_i \vdash_{\Sigma, \Omega} \isTerm{t_i} : \simsub{A_i}{\rho}$ for each $i$,
  \end{enumerate}
  corresponding to rules $\Rule{Var}$, $\Rule{Anno}$, and $\Rule{Op}$ in \Cref{fig:extrinsic-typing} respectively.
\end{definition}

\begin{example}
  Raw terms (\Cref{fig:STLC-raw-terms}) and typing derivations (\Cref{fig:STLC-typing-derivations}) for simply typed $\lambda$-calculus can be specified by the type signature $\Sigma_{\bto}$ (\Cref{ex:type-signature-for-function-type}) and the binding signature consisting of 
 \[
   \aritysymbol{\mathsf{app}}{(A, B)}{(A \bto B), A}{B}
   \quad\text{and}\quad
   \aritysymbol{\mathsf{abs}}{(A , B)}{[A]B}{(A \bto B)}.
 \]
 Rules $\Rule{Abs}$ and $\Rule{App}$ in simply typed $\lambda$-calculus are subsumed by the $\Rule{Op}$ rule schema, as an application $t\;u$ and an abstraction $\lam{x}t$ can be introduced as $\tmOp_{\mathsf{app}}(t, u)$ and $\tmOp_{\mathsf{abs}}(x.t)$, respectively.
\end{example}

\subsection{Bidirectional Binding Signatures and Bidirectional Type Systems} \label{subsec:bidirectional-system}
For a bidirectional type system, typing judgements appear in two forms: $\Gamma |- t \syn A$ and $\Gamma |- t \chk A$, but these two typing judgements can be considered as a single typing judgement $\Gamma |- t :^\dir{d} A$, additionally indexed by a \emph{mode} $d : \Mode$---which can either be $\syn$ or $\chk$.
Therefore, to define a bidirectional type system, we further enrich the concept of binding arity by incorporating modes:

\begin{definition} \label{def:bidirectional-binding-signature}
  A \emph{bidirectional binding arity} with a set $T$ of sorts is an inhabitant of
  \[
    \left(T^* \times T \times \Mode \right)^* \times T \times \Mode.
  \]
  Similarly, a bidirectional binding arity is denoted by ${[\Delta_1]A_{1}^{\dir{d_1}}, \ldots, [\Delta_{n}] A^{\dir{d_n}}_{n}} \to {A_0^{\dir{d}}}$.
\end{definition}
Compared to a binding arity, a bidirectional binding arity specifies additionally the mode of each of its argument and the resulting mode.
For example, the $\ChkRule{Abs}$ rule (\Cref{fig:STLC-bidirectional-typing-derivations}) has the arity ${[A]B^{\chk}}\to{(A \bto B)^{\chk}}$ with $T = \Type_{\Sigma}(\{A, B\})$ indicating additionally that $\lam{x}t$ and its argument $t$ are in checking mode.
Similarly, the $\SynRule{App}$ rule has the arity ${(A \bto B)^{\syn}, A^{\chk}} \to {B^{\syn}}$.

\begin{definition}
  For a type signature $\Sigma$, a \emph{bidirectional binding signature} $\Omega$ is a set $O$ with
  \[
    \mathit{ar}\colon O \to \sum_{\Xi : \N} \left(\Cxt_{\Sigma}(\Xi) \times \Type_{\Sigma}(\Xi) \times {\Mode}\right)^* \times \Type_{\Sigma}(\Xi) \times {\Mode}.
  \]
\end{definition}
Similar to a binding signature, each $o:O$ is meant to represent a term construct except $\SynRule{Var}$, $\SynRule{Anno}$, and $\ChkRule{Sub}$ in a bidirectional type system.
We write $\aritysymbol{o}{\Xi}{[\Delta_1]A_{1}^{\dir{d_1}}, \ldots, [\Delta_{n}] A^{\dir{d_n}}_{n}}{A_0^{\dir{d}}}$ to indicate an operation $o$ with the number $\Xi$ of type variables and its arity with sort $\Type_{\Sigma}(\Xi)$.
Finally, a bidirectional type system $(\Sigma, \Omega)$ refers to a pair of $\Sigma$ and a bidirectional binding signature $\Omega$.

Every bidirectional binding signature $\Omega$ gives rise to a binding signature $\erase{\Omega}$ if we erase modes from $\Omega$, so a bidirectional binding signature $\Omega$ also specifies a simply typed language, including its raw terms and typing derivations.
We call $\erase{\Omega}$ the \emph{(mode) erasure} of $\Omega$.

\begin{definition}\label{def:bidirectional-typing-derivations}\label{def:mode-derivations}
  \begin{figure}
    \centering
    \small
    \judgbox{\Gamma |-_{\Sigma, \Omega} \isTerm{t} :^\dir{d} A}{A raw term $\isTerm{t}$ is of type $A$ without type variables in mode $\dir{d}$ under $\Gamma$}
    \begin{mathpar}
      \inferrule{(x : A) \in \Gamma}{\Gamma |-_{\Sigma, \Omega} \isTerm{x} :^{\syn} A}\,\SynRule{Var}
      \and
      \inferrule{\Gamma |-_{\Sigma, \Omega} \isTerm{t} :^{\chk} A}{\Gamma |-_{\Sigma, \Omega} (\isTerm{t \annotate A}) :^{\syn}  A}\,\SynRule{Anno}
      \and
      \inferrule{\Gamma |-_{\Sigma, \Omega} \isTerm{t} :^{{\syn}} B \\ B = A}{\Gamma |-_{\Sigma, \Omega} \isTerm{t} :^{\chk} A}\,\ChkRule{Sub}
      \\
      \inferrule{\rho\colon \Sub{\Xi}{\emptyset} \\ \Gamma, \simsub{\vars{x}_\isTerm{1} : \Delta_{1}}{\rho} |-_{\Sigma, \Omega} \isTerm{t_{1}} :^\dir{d_1} \simsub{A_1}{\rho} \\
        \cdots \\
      \Gamma, \simsub{\vars{x}_\isTerm{n} : \Delta_{n}}{\rho} |-_{\Sigma, \Omega} \isTerm{t_n} :^{\dir{d_n}} \simsub{A_{n}}{\rho}}
      {\Gamma |-_{\Sigma, \Omega} \tmOpts :^{\dir{d}} \simsub{A_0}{\rho}} \,\mathsf{Op}
      \\ \text{for $\aritysymbol{o}{\Xi}{[\Delta_1]A_{1}^{\dir{d_1}}, \ldots, [\Delta_{n}] A_{n}^{\dir{d_n}}}{A_0^{\dir{d}}}$ in $\Omega$}
    \end{mathpar}
    \caption{Bidirectional typing derivations}
    \label{fig:bidirectional-typing-derivations}
  \end{figure}
  \begin{figure}
    \centering
    \small
    \judgbox{V |-_{\Sigma, \Omega} \isTerm{t}^\dir{d}}{A raw term $\isTerm{t}$ is in mode $d$ with free variables in $V$}
    \begin{mathpar}
      \inferrule{x \in V}{V |-_{\Sigma, \Omega} \isTerm{x}^{\syn}}\,\SynRule{Var}
      \and
      \inferrule{\cdot |-_{\Sigma} A \\ V |-_{\Sigma, \Omega}\isTerm{t}^{\chk}}{V |-_{\Sigma, \Omega} (\isTerm{t \annotate A})^{\syn}}\,\SynRule{Anno}
      \and
      \inferrule{V |-_{\Sigma, \Omega} \isTerm{t}^{\syn}}{V |-_{\Sigma, \Omega} \isTerm{t}^{\chk}}\,\ChkRule{Sub}
      \and
      \inferrule{V, \vars{x}_1 |-_{\Sigma, \Omega} \isTerm{t_1}^\dir{d_1} \\ \cdots \\ V, \vars{x}_{n} |-_{\Sigma, \Omega} \isTerm{t_n}^\dir{d_n}}
      {V |-_{\Sigma, \Omega} \tmOpts^\dir{d}}\,\Rule{Op}
      \and \text{for $\aritysymbol{o}{\Xi}{[\Delta_1]A_{1}^{\dir{d_1}}, \ldots, [\Delta_{n}] A^{\dir{d_n}}_{n}}{A_0^{\dir{d}}}$}
    \end{mathpar}
    \caption{Mode derivations}
    \label{fig:mode-derivations}
  \end{figure}
  For a bidirectional type system $(\Sigma, \Omega)$,
  \begin{itemize}
    \item the set of \emph{bidirectional typing derivations} of $\Gamma \vdash_{\Sigma, \Omega} t :^\dir{d} A$, indexed by a context $\Gamma$ of typed variables, a raw term $\isTerm{t}$ under $\erase{\Gamma}$, a mode $\dir{d}$, and a type $A$, is defined in \Cref{fig:bidirectional-typing-derivations} and particularly
          \[
            \Gamma |-_{\Sigma, \Omega} \tmOpts :^{\dir{d}} \simsub{A_0}{\rho}
          \]
          has a derivation for $\aritysymbol{o}{\Xi}{[\Delta_1]A_{1}^{\dir{d_1}}, \ldots, [\Delta_{n}] A_{n}^{\dir{d_n}}}{A_0^{\dir{d}}}$ in $\Omega$ if there is a function $\rho\colon \Xi \to \Type_{\Sigma}(\emptyset)$ and a derivation of $\Gamma, \vars{x}_{\isTerm{i}} : \Delta_i \vdash_{\Sigma, \Omega} \isTerm{t_i} :^{\dir{d_i}} \simsub{A_i}{\rho}$ for each $i$;
    \item the set of \emph{mode derivations} of $V |-_{\Sigma, \Omega} t^\dir{d}$, indexed by a list $V$ of variables, a raw term $\isTerm{t}$ under $V$, and a mode $d$, is defined in \Cref{fig:mode-derivations}.
  \end{itemize}
  $\boxed{\Gamma \vdash_{\Sigma, \Omega} \isTerm{t} \syn A}$ and $\boxed{\Gamma \vdash_{\Sigma, \Omega} \isTerm{t} \chk A}$
  are shorthands for ${\Gamma \vdash_{\Sigma, \Omega} \isTerm{t} :^{\syn} A}$ and ${\Gamma \vdash_{\Sigma, \Omega} \isTerm{t} :^{\chk} A}$ respectively.
\end{definition}

\begin{example}
  Bidirectional typing derivations and mode derivations for simply typed $\lambda$-calculus can be specified by the type signature $\Sigma_{\bto}$ (\Cref{ex:type-signature-for-function-type}) and the bidirectional binding signature consisting of $\aritysymbol{\mathsf{abs}}{A , B}{[A]B^{\chk}}{(A \bto B)^{\chk}}$ and $\aritysymbol{\mathsf{app}}{A, B}{(A \bto B)^{\syn}, A^{\chk}}{B^{\syn}}$.
\end{example}

After developing these general definitions, we are now able to reason about constructions and properties that hold for any bidirectional simple type system $(\Sigma, \Omega)$.
