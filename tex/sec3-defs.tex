%!TEX root = BiSig.tex

\section{Simple Type Theories and Bidirectional Type Systems}\label{sec:defs}
This section provides generic definitions
%\footnote{%
%Here's the 'small print': Our definitions cover typical examples and set the scope for bidirectional simple type systems discussed, but do not offer comprehensive coverage of all possibilities.}
of simple types, simple type theories, and bidirectional type systems using simply typed $\lambda$-calculus as our running example.

Our definitions are defined in two steps:
\begin{enumerate*}
\item we first introduce a notion of signature which includes a set of operation symbols and an assignment of arities to each operation;
\item then, we define abstract syntax trees inductively with primitive constructs and constructs specified by a given signature.
\end{enumerate*}
Upon moving from simple types to bidirectionally typed terms, the notion of arity, initially as the number of arguments of an operation, is enriched to incorporate an extension context for each argument and a mode denoting the direction of type information flow.

\subsection{Signatures and Simple Types} \label{subsec:simple-types}
Simple types of a language is understood intuitively as a collection of types whose formation judgement is not indexed by anything and the only datum needed for specifying a type construct is its number of arguments: 

\begin{definition} \label{def:simple-signature}
  \begin{figure}
    \begin{minipage}[b]{.6\textwidth}
      \centering
      \small
      \judgbox{\Xi|-_{\Sigma} A}{$A$ is a well-formed type with type variables in $\Xi$}
      \begin{mathpar}
        \inferrule{\Xi \ni X_i}{\Xi |-_\Sigma X_i} \and
        \inferrule{\Xi |-_{\Sigma} A_1 \\ \cdots \\ \Xi |-_{\Sigma} A_n}{\Xi |-_{\Sigma} \tyOp_i(A_1, \ldots, A_n)}\;\text{where $n = \arity(i)$}
      \end{mathpar}
      \caption{Simple types}
      \label{fig:simple-type}
    \end{minipage}
    \begin{minipage}[b]{.35\textwidth}
      \centering
      \small
      \judgbox{\Xi |-_{\Sigma} \Gamma}{}
      \begin{mathpar}
        \inferrule{ }{\Xi |-_{\Sigma} \cdot }\and
        \inferrule{\Xi |-_{\Sigma} A \\ \Xi|-_{\Sigma} \Gamma}{\Xi |-_{\Sigma} \Gamma, x : A}
      \end{mathpar}
      \caption{Contexts}
    \label{fig:simple-context}
    \end{minipage}
  \end{figure}

  A \emph{signature} $\Sigma$ for simple types consists of a set\footnote{%
    Even though our theory is developed in Martin-L\"of type theory, the term `set' is used instead of `type' to avoid the obvious confusion. 
    As we work with Martin-L\"of type theory with \AxiomK, all types are actually sets in the sense of homotopy type theory where all inhabitants of its identity type are proved equal.
  }
  $I$ with a decidable equality and an \emph{arity} function $\arity\colon I \to \mathbb{N}$.
  For a signature $\Sigma$, a \emph{type} $A : \Type_{\Sigma}(\Xi)$ over a variable set $\Xi$ is either
  \begin{enumerate}
    \item a variable in $\Xi$ or
    \item $\tyOp_{i}(A_1, \ldots, A_n)$ for some $i:I$ with $\arity(i) = n$ and types $A_1,\ldots, A_n$
  \end{enumerate}
  as defined in \Cref{fig:simple-type}.
  A \emph{context} $\Gamma \colon \Cxt_{\Sigma}(\Xi)$ over $\Xi$ is a list $\Gamma$ of types over $\Xi$ as defined in \Cref{fig:simple-context}. 
\end{definition}
Note that the second clause is a rule schema giving rise to as many rules as inhabitants $i$ in $I$.

\begin{example} \label{ex:type-signature-for-function-type}
  Simply typed $\lambda$-calculus includes function types $A \bto B$ and typically a base type~$\mathtt{b}$ to ensure that the set of all types without type variables is non-empty.
  The type signature $\Sigma_{\bto}$ used to define types in simply typed $\lambda$-calculus consists of a binary operation $\mathsf{imp}$ and a nullary operation $\mathsf{b}$ where $\arity(\mathsf{imp}) = 2$ and $\arity(\mathsf{b}) = 0$.
  Then, all types in simply typed $\lambda$-calculus can be given as $\Sigma_{\bto}$-types over the empty set where $A \bto B$ is introduced as $\tyOp_{\mathsf{imp}}(A, B)$ and $\mathtt{b}$ as $\tyOp_{\mathsf{b}}$. 
\end{example}

Without the loss of generality, we may use the set $\Fin(n)$ of natural numbers less than $n$ as the set of type variables in this paper, following the inductive definition by \citet{Dybjer1994}.
In bidirectional type synthesis, it is necessary to have a decidable equality on $\Type_{\Sigma}(\Xi)$, as we need to compare the synthesized type $B$ with a given type $A$ for the $\Rule{Sub}$ rule.
When $\Xi$ has a decidable equality, the desired decidable equality can be given.
Since the arity of a type operation is always finite, it is sufficient to use a finite set like $\Fin(n)$.
Additionally, $\Fin(n)$ has a decidable equality, ensuring that the set of simple types over $\Fin(n)$ also has a decidable quality.
Therefore, for convenience, we can represent the set of type variables using a natural number.
However, for illustrative purposes, variables will still be assigned names.

As \Cref{def:simple-signature} includes type variables, we introduce the typical meta-operations: substitution.
\begin{definition}
  The \emph{(simultaneous) substitution} of a type $A$ over $\Xi$ for a function $\rho\colon\Xi \to \Type_{\Sigma}(\Xi')$ mapping $A$ to a type $\simsub{A}{\rho}$ over $\Xi'$ is defined as usual.
  By abuse of notation, the substitution $\simsub{\Gamma}{\rho}$ of a context $\Gamma$ is defined by applying substitution $\simsub{A}{\rho}$ to each type $A$ in the context.
\end{definition}

\subsection{Binding Signatures and Simple Type Theories} \label{subsec:binding-sig}

For a type signature $\Sigma$, a simple type theory consists of
\begin{enumerate*}
  \item a set of raw terms $\isTerm{t}$ indexed by a set $V$ of untyped variables where each construct is allowed to bind some variables (as $\Rule{Abs}$) and to take multiple arguments (as $\Rule{App}$) like \Cref{fig:STLC-raw-terms};
  \item a set of typing derivations indexed by a list $\Gamma$ of typed variables, a type~$A$, and a raw term $\isTerm{t}$ to set their type constraints like \Cref{fig:STLC-typing-derivations}. 
\end{enumerate*}
Therefore, to specify a construct like $\Rule{Abs}$ or $\Rule{App}$, we need to enrich the notion of signatures with an extension context for variable binding for each argument, a type for each argument, and a type for the operation:
\begin{definition}\label{def:binding-signature}
  For a type signature $\Sigma$, a \emph{binding signature} $\Omega$ consists of a set $O$ and a function
  \[
    \mathit{ar}\colon O \to \sum_{\Xi : \N} \left(\Cxt_\Sigma(\Xi) \times \Type_\Sigma(\Xi)\right)^* \times \Type_\Sigma(\Xi).
  \]
\end{definition}
Each inhabitant $o: O$, meant to represent a term construct $\tmOp_o$ in a simple type theory, has a triple $\left(\Xi, \left[\left(\Delta_1; A_1\right), \ldots, \left(\Delta_{n}; A_{n}\right) \right], A_0\right)$ as its arity $\arity_o$ where
\begin{enumerate}
  \item $\Xi$ is the number of type variables, 
  \item $A : \Type_\Sigma(\Xi)$ is for the type of $\tmOp_o$, and
  \item $\left[\left(\Delta_1; A_{1}\right), \ldots, \left(\Delta_{n}; A_{n}\right) \right]$ is a list of pairs where
  \item the $i$-th pair $(\Delta_i, A_i) :\Cxt_{\Sigma}(\Xi) \times \Term_{\Sigma}(\Xi)$ are for types of the binding variables and the type of the $i$-th argument of $\tmOp_{o}$.
\end{enumerate}
For brevity, we write $o \colon \Xi \rhd [\Delta_1]A_{1}, \ldots, \left[\Delta_{n}\right] A_{n} \to A_0$ to indicate an operation with its arity and omit $[\Delta]$ if $\Delta$ is empty. 
For example, the $\Rule{Abs}$ rule can be specified by the operation 
\[
  \mathsf{abs}\colon A , B \rhd [A]B \to (A \bto B)
\]
indicating that the $\Rule{Abs}$ rule has two type variables $A$ and $B$, one argument of type $B$ and which binds a variable of type $A$, and the type $A \bto B$ for the construct $\lambda$.
Similarly, the $\Rule{App}$ rule can be specified by $\mathsf{app}\colon A, B \rhd A \bto B, A \to B$ where extension contexts for its two arguments are empty.

We define raw terms specified by a type signature $\Sigma$ and a binding signature $\Omega$ as follows.
\begin{definition}
\begin{figure}
  \centering
  \small
  \judgbox{V |-_{\Sigma, \Omega} \isTerm{t}}{Given a list V of variables, $\isTerm{t}$ is a raw term for the signature $(\Sigma, \Omega)$ with free variables in $V$}
  \begin{mathpar}
    \inferrule{\isTerm{x} \in V}{V |-_{\Sigma, \Omega} \isTerm{x}}\,\Rule{Var}
    \and
    \inferrule{\cdot |-_{\Sigma} A \\ V |-_{\Sigma, \Omega}\isTerm{t}}{V |-_{\Sigma, \Omega} \isTerm{t \annotate A}}\,\Rule{Anno}
    \and
    \inferrule{V, \vars{x}_\isTerm{1} |-_{\Sigma, \Omega} \isTerm{t_1} \\ \cdots \\ V, \vars{x}_\isTerm{n} |-_{\Sigma, \Omega} \isTerm{t_n}}
    {V |-_{\Sigma, \Omega} \tmOpts }\,\Rule{Op}
  \end{mathpar}
%  \begin{flushright}
%    for $o \colon \Xi \rhd [\Delta_1]A_{1}, \ldots, [\Delta_{n}] A_{n} \to A$ in $\Omega$
%  \end{flushright}%
  \caption{Raw terms}
  \label{fig:raw-terms}
\end{figure}
  In a simple type theory specified by $(\Sigma, \Omega)$, the set of \emph{raw terms} indexed by a context~$V$ of variables consists of
  \begin{enumerate}
    \item variables in $V$,
    \item annotations $\isTerm{t \annotate A}$ for some raw term $t$ and a type $A$, and
    \item a construct $\tmOpts$ for some $o \colon \Xi \rhd [\Delta_1]A_{1}, \ldots, [\Delta_{n}] A_{n} \to A_0$ in $O$, where $\vars{x}_{\isTerm{i}}$'s are lists of variables whose length is equal to the length of~$\Delta_i$ and $t_i$'s are raw terms under the context $V, \vars{x}_i$,
  \end{enumerate}
  corresponding to rules $\Rule{Var}$, $\Rule{Anno}$, and $\Rule{Op}$ in \Cref{fig:raw-terms} respectively.
\end{definition}


The definition of typing derivations is slightly involved.
We need some information to compare types on the object level during type synthesis and substitute those type variables in a typing derivation $\Gamma \vdash \tmOpts : A$ for an operation $o$ in $\Omega$ at some point.
Hence we choose to include a substitution as part of its typing derivation explicitly:
\begin{definition}\label{def:typing-derivations}
  \begin{figure}
    \centering
    \small
    \judgbox{\Gamma |-_{\Sigma, \Omega} \isTerm{t} : A}{A raw term $\isTerm{t}$ has a type $A$ without type variables under $\Gamma$ for the signature $(\Sigma, \Omega)$}
    \begin{mathpar}
      \inferrule{(\isTerm{x} : A) \in \Gamma}{\Gamma |-_{\Sigma, \Omega} \isTerm{x} : A}\,\Rule{Var}
      \and
      \inferrule{\Gamma |- \isTerm{t} : A}{\Gamma |- (\isTerm{t \annotate A}) : A}\,\Rule{Anno}
      \and
      \inferrule{\rho : \Sub{\Xi}{\emptyset} \\  \Gamma, \vec{\isTerm{x}}_\isTerm{1} : \simsub{\Delta_{1}}{\rho} |-_{\Sigma, \Omega} \isTerm{t_1} : \simsub{A_{1}}{\rho} \quad\cdots\quad \Gamma, \vec{\isTerm{x}}_\isTerm{n} : \simsub{\Delta_{n}}{\rho} |-_{\Sigma, \Omega} \isTerm{t_n} : \simsub{A_{n}}{\rho}}
      {\Gamma |-_{\Sigma, \Omega} \tmOpts : \simsub{A_0}{\rho}}\,\Rule{Op}
    \end{mathpar}
    \caption{Typing derivations}
    \label{fig:extrinsic-typing}
  \end{figure}
  In a simple type theory specified by $(\Sigma, \Omega)$, the set of \emph{typing derivations} of $\Gamma \vdash \isTerm{t} : A$ indexed by a context $\Gamma$ of typed variables, a raw term under $\erase{\Gamma}$, and a type $A$ consists of 
  \begin{enumerate}
    \item a derivation of $\Gamma |- x : A$ if $x : A$ is in $\Gamma$,
    \item a derivation of $\Gamma |- (t \annotate A) : A$ if $\Gamma \vdash \isTerm{t} : A$ is derivable, and
    \item a derivation of $\Gamma |- \tmOpts : A$ for $o \colon \Xi \rhd [\Delta_1]A_1, \ldots, [\Delta_{n}]A_{n} \to A_0$ if there is a function $\rho\colon \Xi \to \Type_{\Sigma}(\emptyset)$ such that $A = \simsub{A_0}{\rho}$ and $\Gamma, \vars{x}_{\isTerm{i}} : \Delta_i \vdash \isTerm{t_i} : \simsub{A_i}{\rho}$ is derivable for all $i$,
  \end{enumerate}
  corresponding to rules $\Rule{Var}$, $\Rule{Anno}$, and $\Rule{Op}$ in \Cref{fig:extrinsic-typing} respectively.
  For better readability, the subscript $(\Sigma, \Omega)$ in the above typing judgements is suppressed.
\end{definition}
Note that, by definition, our simple type theory is always syntax-directed, since each rule in \Cref{fig:raw-terms} corresponds exactly to one rule in \Cref{fig:extrinsic-typing}. 
The $\Rule{Op}$ in both figures is a rule schema and gives rise to as many rules as there are operations in $o : O$.

\begin{example}
  Raw terms and typing derivations for simply typed $\lambda$-calculus (\Cref{fig:STLC-raw-terms,fig:STLC-typing-derivations}) can be specified by the type signature $\Sigma_{\bto}$ (\Cref{ex:type-signature-for-function-type}) and the binding signature consisting of 
 \[
   \mathsf{app}\colon A, B \rhd A \bto B, A \to B
   \quad\text{and}\quad
   \mathsf{abs}\colon A , B \rhd [A]B \to (A \bto B).
 \]
 Rules $\Rule{Abs}$ and $\Rule{App}$ in simply typed $\lambda$-calculus are subsumed by the $\Rule{Op}$ rule schema, as terms $\tmOp_{\mathsf{app}}(t, u)$ and $\tmOp_{\mathsf{abs}}(x.t)$ are exactly an application $t\;u$ and an abstraction $\lam{x}t$, respectively.
\end{example}

\subsection{Bidirectional Binding Signatures and Bidirectional Type Systems} \label{subsec:bidirectional-system}
Finally, for a bidirectional type system, we have raw terms and typing derivations like a simple type theory, but its typing judgements come in two forms $\Gamma |- t \syn A$ and $\Gamma |- t \chk A$.
Observe that these two typing judgements are just one typing judgement $\Gamma |- t :^\dir{d} A$ indexed additionally by a \emph{mode} $d : \Mode$ where $\Mode$ consists of two inhabitants $\syn$ for synthesis and $\chk$ for checking.
Hence, to specify a bidirectional type system, we need further enrich the notion of binding signatures with a mode for each argument and a mode for an operation itself as follows.

\begin{definition} \label{def:bidirectional-binding-signature}
  For a type signature $\Sigma$, a \emph{bidirectional binding signature} $\Omega$ is a set $O$ with a function
  \[
    \mathit{ar}\colon O \to \sum_{\Xi : \N} \left(\Cxt_{\Sigma}(\Xi) \times \Type_{\Sigma}(\Xi) \times {\Mode}\right)^* \times \Type_{\Sigma}(\Xi) \times {\Mode}.
  \]
\end{definition}
Each inhabitant $o:O$ is similarly meant to represent a term construct $\tmOp_o$ in a bidirectional type system but the arity of $o : O$ becomes a $4$-tuple $\left(\Xi, \left[\left(\Delta_1; A_1; d_1\right), \ldots, \left(\Delta_{n}; A_{n}; d_n\right) \right], A_0, d\right)$
including additionally $d$ and $d_i$'s for the modes of the construct $\tmOp_o$ and its arguments respectively.

For brevity, we write $o \colon \Xi \rhd [\Delta_1]A_{1}^{\dir{d_1}}, \ldots, [\Delta_{n}] A^{\dir{d_n}}_{n} \to A_0^{\dir{d}}$ to indicate an operation with its arity. 
For example, the $\ChkRule{Abs}$ rule in \Cref{fig:STLC-bidirectional-typing-derivations} can be specified by $\mathsf{abs}\colon A , B \rhd [A]B^{\chk} \to (A \bto B)^{\chk}$ indicating additionally that the construct $\lambda$ and its argument are in checking mode.
Similarly, the $\SynRule{App}$ rule can be specified by $\mathsf{app}\colon A, B \rhd (A \bto B)^{\syn}, A^{\chk} \to B^{\syn}$.

\begin{remark}
  Every bidirectional binding signature $\Omega$ gives rise to a binding signature $\erase{\Omega}$ if we erase modes from $\Omega$, so a bidirectional binding signature $\Omega$ also specifies a simple type theory, including its raw terms and typing derivations.
  For this notion, we call $\erase{\Omega}$ the \emph{(mode) erasure} of $\Omega$.
\end{remark}


We generalise bidirectional typing rules as well as model derivations for simply typed $\lambda$-calculus in \Cref{fig:STLC-bidirectional-typing-derivations,fig:STLC-mode-derivations} to derivations for a bidirectional type system specified by $(\Sigma, \Omega)$ where $\Sigma$ is still a type signature and $\Omega$ is a bidirectional binding signature, similar to \Cref{def:typing-derivations} for typing derivations but with an additional $\ChkRule{Sub}$ rule:
\begin{definition}\label{def:bidirectional-typing-derivations}\label{def:mode-derivations}
  \begin{figure}
    \centering
    \small
    \judgbox{\Gamma |-_{\Sigma, \Omega} \isTerm{t} :^\dir{d} A}{A raw term $\isTerm{t}$ is of type $A$ without type variables in mode $\dir{d}$ under $\Gamma$}
    \begin{mathpar}
      \inferrule{(x : A) \in \Gamma}{\Gamma |-_{\Sigma, \Omega} \isTerm{x} :^{\syn} A}\,\SynRule{Var}
      \and
      \inferrule{\Gamma |-_{\Sigma, \Omega} \isTerm{t} :^{\chk} A}{\Gamma |-_{\Sigma, \Omega} (\isTerm{t \annotate A}) :^{\syn}  A}\,\SynRule{Anno}
      \and
      \inferrule{\Gamma |-_{\Sigma, \Omega} \isTerm{t} :^{{\syn}} B \\ B = A}{\Gamma |-_{\Sigma, \Omega} \isTerm{t} :^{\chk} A}\,\ChkRule{Sub}
      \\
      \inferrule{\rho\colon \Sub{\Xi}{\emptyset} \\ \Gamma, \simsub{\vars{x}_\isTerm{1} : \Delta_{1}}{\rho} |-_{\Sigma, \Omega} \isTerm{t_{1}} :^\dir{d_1} \simsub{A_1}{\rho} \\
        \cdots \\
      \Gamma, \simsub{\vars{x}_\isTerm{n} : \Delta_{n}}{\rho} |-_{\Sigma, \Omega} \isTerm{t_n} :^{\dir{d_n}} \simsub{A_{n}}{\rho}}
      {\Gamma |-_{\Sigma, \Omega} \tmOpts :^{\dir{d}} \simsub{A_0}{\rho}} \,\mathsf{Op}
    \end{mathpar}
    Abbreviations: $\boxed{\Gamma \vdash_{\Sigma, \Omega} \isTerm{t} \syn A} \defeq \boxed{\Gamma \vdash_{\Sigma, \Omega} \isTerm{t} :^{\syn} A}$ and $\boxed{\Gamma \vdash_{\Sigma, \Omega} \isTerm{t} \chk A} \defeq \boxed{\Gamma \vdash_{\Sigma, \Omega} \isTerm{t} :^{\chk} A}$
    \caption{Bidirectional typing derivations}
    \label{fig:bidirectional-typing-derivations}
  \end{figure}
  \begin{figure}
    \centering
    \small
    \judgbox{V |-_{\Sigma, \Omega} \isTerm{t}^\dir{d}}{A raw term $\isTerm{t}$ is in mode $d$}
    \begin{mathpar}
      \inferrule{x : V}{V |-_{\Sigma, \Omega} \isTerm{x}^{\syn}}\,\SynRule{Var}
      \and
      \inferrule{\cdot |-_{\Sigma} A \\ V |-_{\Sigma, \Omega}\isTerm{t}^{\chk}}{V |-_{\Sigma, \Omega} (\isTerm{t \annotate A})^{\syn}}\,\SynRule{Anno}
      \and
      \inferrule{V |-_{\Sigma, \Omega} \isTerm{t}^{\syn}}{V |-_{\Sigma, \Omega} \isTerm{t}^{\chk}}\,\ChkRule{Sub}
      \and
      \inferrule{V, \vars{x}_1 |-_{\Sigma, \Omega} \isTerm{t_1}^\dir{d_1} \\ \cdots \\ V, \vars{x}_{n} |-_{\Sigma, \Omega} \isTerm{t_n}^\dir{d_n}}
      {V |-_{\Sigma, \Omega} \tmOpts^\dir{d}}\,\Rule{Op}
    \end{mathpar}
    \caption{Mode derivations}
    \label{fig:mode-derivations}
  \end{figure}
  In a bidirectional type system specified by $(\Sigma, \Omega)$,
  \begin{itemize}
    \item the set of \emph{bidirectional typing derivations} of $\Gamma \vdash t :^\dir{d} A$ indexed by a context $\Gamma$ of typed variables, a raw term $\isTerm{t}$ under $\erase{\Gamma}$, a mode $\dir{d}$, and a type $A$ is defined by \Cref{fig:bidirectional-typing-derivations};
    \item the set of \emph{mode derivations} of $V |- t^\dir{d}$ indexed by a list $V$ of variables, a raw term $\isTerm{t}$ under $V$, and a mode $d$ is defined by \Cref{fig:mode-derivations}.
  \end{itemize}
  The subscript $(\Sigma, \Omega)$ in judgements above is suppressed.
\end{definition}

\begin{example}
  Bidirectional typing derivations and mode derivations for simply typed $\lambda$-calculus (\Cref{fig:STLC-bidirectional-typing-derivations,fig:STLC-mode-derivations}) can be specified by the type signature $\Sigma_{\bto}$ (\Cref{ex:type-signature-for-function-type}) and the bidirectional binding signature consisting of $\mathsf{abs}\colon A , B \rhd [A]B^{\chk} \to (A \bto B)^{\chk}$ and $\mathsf{app}\colon A, B \rhd (A \bto B)^{\syn}, A^{\chk} \to B^{\syn}$.
\end{example}

After developing these generic definitions, we are now able to reason about any bidirectional simple type system specified by a pair of signatures $(\Sigma, \Omega)$ in the following two sections.
