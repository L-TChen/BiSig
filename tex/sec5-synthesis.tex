%!TEX root = BiSig.tex

\section{Bidirectional Type Synthesis and Checking} \label{sec:type-synthesis}
This section focuses on defining mode-correctness and deriving bidirectional type synthesis for any mode-correct bidirectional type system $(\Sigma, \Omega)$.
\LT{trichotomy first or last?}
We start with the statement of the decidability of bidirectional synthesis and the trichotomy on raw terms for mode-correct bidirectional type systems in \Cref{subsec:trichotomy}, but defer the definition of mode-correctness until \Cref{sec:mode-correctness} and the decidability proof until \Cref{subsec:bidirectional-synthesis-checking}.
We will then formalise mode-correctness and show the uniqueness of synthesized types in \Cref{sec:mode-correctness}.
This uniqueness property means that any two synthesised types for the same raw term $t$ under the same context $\Gamma$ have to be equal.
This will be used later in the proof of the decidability of bidirectional type synthesis and checking in \Cref{subsec:bidirectional-synthesis-checking}.


\subsection{Mode Correctness}\label{sec:mode-correctness}
As \citet{Dunfield2021} outlined, mode-correctness for a bidirectional type system means that for every typing rule:
\begin{enumerate*}
\item each `input' type variable in a premise must be synthesised from `earlier' premises or provided by the conclusion, if the rule is checking;
\item each `output' type variable in the conclusion should have been synthesised from premises already, if the rule is synthesis.
\end{enumerate*}
Here an `input' type variable refers to types in an extension context and the type of a premise in the checking mode.
It is important to note that the order of premises in a bidirectional typing rule also matters, since synthesised types are accumulated during type synthesis.

Consider the rule $\ChkRule{Abs}$ (\Cref{fig:STLC-bidirectional-typing-derivations}) as an example.
This rule is mode-correct, as the type variables $A$ and $B$ in its only premise are already provided by its conclusion $A \bto B$.
Likewise, the rule $\SynRule{App}$ for an application term $\isTerm{t\;u}$ is mode-correct because:
\begin{enumerate*}
\item the type $A \bto B$ of the first argument $t$ is synthesised, thereby ensuring type variables $A$ and $B$ must be known if successfully synthesised;
\item the type of the second argument $u$ is checked against $A$, which has been synthesised earlier;
\item as a result, the type of an application $t\;u$ can be synthesised.
\end{enumerate*}

Now we proceed with the formal definition of mode-correctness.
As we have outlined, the condition of mode-correctness for a synthesis rule is different from that of a checking rule, and the argument order also matters.
Defining the condition directly for a signature can be somewhat intricate.
Instead, we choose to define the condition in a few more steps, based on the list of arguments---more specifically, triples of an extension context $\Delta_i$, a type $A_i$, and a mode $\dir{d_i}$---pertaining to an operation, and subsequently on a signature.
We also need some auxiliary definitions for the subset of variables of a type and of a context and the set of variables that have been synthesised:
\begin{definition}
  The finite subset\footnote{%
  There are various definitions for finite subsets of a set within Martin-L\"{o}f type theory.
  However, for our purposes, the choice among these definitions is not a matter of concern.}
  of \emph{variables} which occur in a type $A$ is denoted by $\fv(A)$.
  The subset $\fv(\Gamma)$ of variables in a context $\Gamma$ is defined by $\fv(\cdot) = \emptyset$ and $\fv(\Gamma, A) = \fv(\Gamma) \cup \fv(A)$.
  For a list of \emph{arguments} $\overrightarrow{[\Delta_i]A_i^{d_i}}$, define the set of \emph{synthesis type variables} inductively as 
  \begin{align}
    \label{eq:synvar1}\synvar(\cdot)                                  & = \emptyset  \\
    \label{eq:synvar2}\synvar(\overrightarrow{[\Delta_i]A_i^{\dir{d_i}}}, [\Delta_{n}] A_{n}^{\dir{\chk}}) & = 
    \synvar(\overrightarrow{[\Delta_i]A_i^{\dir{d_i}}}) \\
    \label{eq:synvar3}\synvar(\overrightarrow{[\Delta_i]A_i^{\dir{d_i}}}, [\Delta_{n}] A_{n}^{\dir{\syn}}) & = 
    \synvar(\overrightarrow{[\Delta_i]A_i^{\dir{d_i}}}) \cup \fv(A_{n}).
  \end{align}
\end{definition}
This subset contains type variables of a synthesising argument and they are exactly those type variables that would be synthesised during type synthesis.

\begin{definition}\label{def:mode-correctness}
  The \emph{mode-correctness for an argument list} $\Xi \rhd [\Delta_{1}] A_{1}^{\dir{d}}, \ldots, [\Delta_n]A_{n}^{\dir{d_n}}$  with respect to a subset $S$ of $\Xi$ is defined inductively as
  \begin{align}
    \label{eq:MC1} \MC_{\mathit{as}}( \cdot ) & = \top \\
    \label{eq:MC2} \MC_{\mathit{as}}\left(\overrightarrow{[\Delta_i]A_i^{\dir{d_i}}}, [\Delta_{n}]A_{n}^{\syn}\right) 
    & = \MC_{\mathit{as}}\left(\overrightarrow{[\Delta_i]A_i^{\dir{d_i}}}\right)
    \land \fv(\Delta) \subseteq \left( S \cup \synvar\left(\overrightarrow{[\Delta_i]A_i^{\dir{d_i}}}\right) \right)\\
    \label{eq:MC3} \MC_{\mathit{as}}\left(\overrightarrow{[\Delta_i]A_i^{\dir{d_i}}}, [\Delta_{n}]A_{n}^{\chk}\right)
    & = \MC_{\mathit{as}}\left(\overrightarrow{[\Delta_i]A_i^{\dir{d_i}}}\right)
    \land \fv(\Delta, A_n) \subseteq \left( S \cup \synvar\left(\overrightarrow{[\Delta_i]A_i^{\dir{d_i}}}\right)\right)
  \end{align}
  where \eqref{eq:MC1} means an empty list is always mode-correct.
\end{definition}
This definition encapsulates the idea that every `input' type variable, possibly deriving from a context $\Delta$ or a checking argument $A_n$, must be an `output' variable from $\synvar(\overrightarrow{[\Delta_i]A_i^{\dir{d_i}}})$ or, if the rule is checking, belong to the set $S$ of `input' variables in its conclusion.
This condition must be met for every tail of the argument list as well to ensure that `output' variables accessible at each argument position are from preceding arguments only, hence an inductive definition.
\begin{definition}
  An operation $o\colon \Xi \rhd [\Delta_{1}] A_{1}^{\dir{d}}, \ldots, [\Delta_n]A_{n}^{\dir{d_n}} \to A_0^{\dir{d}}$ is \emph{mode-correct} provided that
  \begin{enumerate}
    \item $d$ is $\chk$, its argument list is mode-correct w.r.t.\ $\fv(A_0)$, and the union $\fv(A_0) \cup \synvar(\overrightarrow{[\Delta_i]A_i^{\dir{d_i}}})$ contains every inhabitant of $\Xi$;
    \item $d$ is $\syn$, its argument list is mode-correct w.r.t.\ $\emptyset$, and the finite subset $\synvar(\overrightarrow{[\Delta_i]A_i^{\dir{d_i}}})$ contains every inhabitant of $\Xi$ and, particularly, $\fv(A_0)$.
  \end{enumerate}
  A bidirectional binding signature $\Omega$ is \emph{mode-correct} if its operations are all mode-correct.
\end{definition}
For a checking operation, an `input' variable of an argument could be derived from $A_0$, as these are known during type checking as an input.
Since every inhabitant of $\Xi$ can be located in either $A_0$ or synthesis variables, we can determine a concrete type for each inhabitant of $\Xi$ during type synthesis.
On the other hand, for a synthesis operation, we do not have any known variables at the onset of type synthesis, so the argument list should be mode-correct with respect to $\emptyset$.
Also, the set of synthesis variables alone should include every type variable in $\Xi$ and particularly in $A_n$.
It is also easy to check the bidirectional type system $(\Sigma_{\bto}, \Omega^{\Leftrightarrow}_{\Lambda}$) in \Cref{ex:signature-simply-typed-lambda} for simply typed $\lambda$-calculus is mode-correct according to our definition.
\LT{perhaps we shall prove that mode-correctness is decidable}

\begin{remark}
  Mode-correctness is fundamentally a condition for typing \emph{rules} themselves, not for derivations.
  Thus, this property cannot be formalised without treating rules as some mathematical object, such as the notion of bidirectional binding signature presented in \Cref{sec:defs}.
  This contrasts with the properties in \Cref{sec:pre-synthesis}, which can still be articulated for individual systems even in the absence of a general definition of bidirectional type systems.
\end{remark}

Now, we set out to show the uniqueness of the synthesised types for a mode-correct bidirectional type system.
For a specific system, its proof is typically a straightforward induction.
However, given the mode-correctness---which incorporates an inductive definition on the argument list---we establish our proof through induction, both on typing derivations and on the argument list:
\begin{lemma}[Uniqueness of the Synthesised Types]\label{thm:unique-syn}
  In a mode-correct bidirectional type system $(\Sigma, \Omega)$, the synthesised types of any two derivations
  \[
    \Gamma |-_{\Sigma, \Omega} \isTerm{t} \syn A
    \quad\text{and}\quad
    \Gamma |-_{\Sigma, \Omega} \isTerm{t} \syn B
  \]
  for the same term $t$ must be equal, i.e.\ $A = B$.
\end{lemma}
\begin{proof}%[Proof of \Cref{thm:unique-syn}]
  We prove the statement by induction on derivations $d_1$ and $d_2$ for $\Gamma |-_{\Sigma, \Omega} \isTerm{t} \syn A$ and $\Gamma |-_{\Sigma, \Omega} \isTerm{t} \syn B$.
  Our system is syntax-directed, so $d_1$ and $d_2$ must be derived from the same rule: 
  \begin{itemize}
    \item $\SynRule{Var}$ follows from that each variable as a raw term refers to the same variable in its context.
    \item $\SynRule{Anno}$ holds trivially, since the synthesised type $A$ is from the term $t \annotate A$ in question.
    \item $\Rule{Op}$: Recall here that a derivation of\/ $\Gamma |- \tmOpts \syn A$ for a synthesis operation $o\colon \Xi \rhd [\Delta_{1}] A_{1}^{\dir{d}}, \ldots, [\Delta_n]A_{n}^{\dir{d_n}} \to A_0^{\syn}$ contains a substitution $\rho$ from the local context $\Xi$ to concrete types \Cref{fig:extrinsic-typing}.
      To prove that any two typing derivations has the same synthesised type, it suffices to show that those substitutions $\rho_1$ and $\rho_2$ agree on variables in $\synvar\left([\Delta_{1}] A_{1}^{\dir{d}}, \ldots, [\Delta_n]A_{n}^{\dir{d_n}}\right)$ so that $\simsub{A_0}{\rho_1} = \simsub{A_0}{\rho_2}$.
      We prove it by induction on the argument list:
      \begin{enumerate}
        \item For the empty list, the statement is vacuously true by~\eqref{eq:synvar1}.
        \item If $\dir{d_{i+1}}$ is checking, then the statement holds for~\eqref{eq:synvar2} by induction hypothesis.
        \item If $\dir{d_{i+1}}$ is synthesis, then $\simsub{\Delta_{i+1}}{\rho_1} = \simsub{\Delta_{i+1}}{\rho_2}$ by mode-correctness~\eqref{eq:MC2} and induction hypothesis (of the list).
          Therefore, under the same context $\Gamma, \simsub{\Delta_{i+1}}{\rho_1} = \Gamma, \simsub{\Delta_{i+1}}{\rho_2}$ the term $t_{i+1}$ must have the same synthesised type $\simsub{A_{i+1}}{\rho_1} = \simsub{A_{i+1}}{\rho_1}$ by induction hypothesis (of the typing derivation), so $\rho_1$ and $\rho_2$ agree on $\fv(A_{i+1})$ in addition to $\synvar\left([\Delta_{1}] A_{1}^{\dir{d}}, \ldots, [\Delta_i]A_{i}^{\dir{d_i}}\right)$, as required for the case \eqref{eq:synvar3} in the definition of $\synvar$.
      \end{enumerate}
  \end{itemize}
\end{proof}

%Uniqueness of the synthesised types is a prevalent property in bidirectional type systems, although the specific proofs can vary depending on the constructs in the system.
%For instance, for derivations of $\Gamma |- t\;u \syn B_i$ for $i = 1, 2$ in simply typed $\lambda$-calculus, the hypothesis is applied to their sub-derivations $\Gamma |- t \syn A_i \bto B_i$ to conclude that $A_1 \bto B_1 = A_2 \bto B_2$ and thus $B_1 = B_2$.
%On the other hand, our proof is based on mode-correctness and need not consider specific sub-derivations.

\subsection{Decidability of Bidirectional Type Synthesis and Checking}\label{subsec:bidirectional-synthesis-checking}
We are ready for the last technical result of this paper---the decidability of bidirectional type synthesis and checking for any mode correct bidirectional type system:
\begin{theorem}[Decidability of Bidirectional Type Synthesis and Checking] \label{thm:bidirectional-type-synthesis-checking}
  In a mode-correct bidirectional type system $(\Sigma, \Omega)$,
  \begin{enumerate}
    \item if $\erase{\Gamma} |-_{\Sigma, \Omega} \isTerm{t}^{\syn}$, then it is decidable whether there is a type~$A$ such that
      \[
        \Gamma |-_{\Sigma, \Omega} \isTerm{t} \syn A;
      \]
    \item if $\erase{\Gamma} |-_{\Sigma, \Omega} \isTerm{t}^{\chk}$, then it is decidable for any $A$ whether
      \[
        \Gamma |-_{\Sigma, \Omega} \isTerm{t} \chk A.
      \]
  \end{enumerate}
\end{theorem}

The interesting part of the proof is the case for the $\Rule{Op}$ rule, so we shall give the insight first before jumping into details.
Recall that a typing derivation for $\tmOpts$ for an operation $o\colon \Xi \rhd [\Delta_{1}] A_{1}^{\dir{d}}, \ldots, [\Delta_n]A_{n}^{\dir{d_n}} \to A_0^{\dir{d}}$ contains a substitution $\rho\colon \Xi \to \Type_{\Sigma}(\emptyset)$.
The goal of type synthesis is exactly to define such a substitution $\rho$ for $\tmOpts$ while synthesising or checking each argument $t_i$, so we have to start with a \emph{partial} substitution $\rho_0$ defined on $\fv(A_0)$ if $d$ is $\chk$ or otherwise nowhere, as an `accumulating argument'.
Then, as we visit each synthesis argument of type $A_{i+1}$, we may be able to extend the domain of a partial substitution $\rho_i$ to include the synthesis variables $\fv(A_{i + 1})$ if type synthesis is successful and also that the synthesised type can be \emph{unified with $A_{i+ 1}$} and \emph{extending} $\rho_i$ to $\bar{\rho_i} = \rho_{i+1}$.
By mode-correctness, the accumulating substitution~$\rho_i$ would be defined on enough synthesis variables so that each type synthesis and checking can be performed on $t_i$ based on its mode derivation $\erase{\Gamma}, \vars{x}_i |-_{\Sigma, \Omega} t_i^{\dir{d_i}}$.
Then, once we go through every argument $t_i$ successfully, we will have a partial substitution $\rho_n$ defined on every variable $x : \Xi$ by mode-correctness (\Cref{def:mode-correctness}), i.e.\ a substitution $\rho_n$ from $\Xi$ to $\Type_{\Sigma}(\emptyset)$.

To make the aforementioned argument holds, it is necessary to compare types and solve a unification problem.
Hence, we assume that the set $\Xi$ of variables has a decidable equality, rather than being an arbitrary set, thereby ensuring that the set $\Type_{\Sigma}(\Xi)$ of types also has a decidable equality.\footnote{%
To simplify our choice, we could simply confine $\Xi$ to any set within the family of sets $\Fin_n$ of naturals less than~$n$.
Given that these sets have a decidable equality and the arity of a type construct is finite, this would be a viable choice.
Indeed, in our formalisation, we adopt $\Fin_n$ as the set of type variables in the definition of $\Type_{\Sigma}$ (see \Cref{sec:formalisation} for details).
However, for the sake of clarity in presentation, we keep using named variables and just assume that $\Xi$ has a decidable equality.}
The unification problem is as follows:
\begin{lemma}
  For any $A$ of\/ $\Type_{\Sigma}(\Xi)$, $B$ of\/ $\Type_{\Sigma}(\emptyset)$, and a partial substitution $\rho \colon \Xi \to \Type_{\Sigma}(\emptyset)$, 
  \begin{enumerate}
    \item either there is a \emph{minimal extension} $\bar{\rho}$ of $\rho$ such that $\simsub{A}{\bar{\rho}} = B$, or 
    \item there is no extension $\sigma$ of $\rho$ such that $\simsub{A}{\sigma} = B$
  \end{enumerate}
  where by an extension $\sigma \geq \rho$ we mean that the domain of $\sigma$ contains the domain $\rho$ and $\sigma(x) = \rho(x)$ for every $x$ in the domain of $\rho$; by a minimal extension $\bar{\rho}$ of $\rho$ we mean an extension $\bar{\rho}$ of $\rho$ such that $\sigma \geq \bar{\rho}$ whenever $\sigma$ is an extension of $\rho$.
\end{lemma}
This lemma can be inferred from the correctness of first-order unification as proved by \citet{McBride2003,McBride2003a}, or be directly proved without unification.
We now proceed with the decidability proof.

\begin{proof}[Proof of {\Cref{thm:bidirectional-type-synthesis-checking}}]
  We prove this statement by induction on the mode derivation\/ $\erase{\Gamma} |-_{\Sigma, \Omega} \isTerm{t}^{\dir{d}}$.
  The two cases \SynRule{Var} and \SynRule{Anno} are straightforward and have nothing to do with mode-correctness.
  The case \ChkRule{Sub} invokes the uniqueness of synthesised types to refute the case that $\Gamma |- \isTerm{t} \syn B$ but $A \neq B$ for a given type $A$.
  The first three cases follow essentially the same argument provided by \citet{Wadler2022}, but we still give the arguments for the sake of completeness.
  The last case \Rule{Op} is new and has been discussed above.
  \begin{itemize}
    \item \SynRule{Var}: As $\erase{\Gamma} |-_{\Sigma, \Omega} \isTerm{t}$, there exists a type $A$ such that $\Gamma |- \isTerm{x} \syn A$.

    \item \SynRule{Anno}: For $\erase{\Gamma} |-_{\Sigma, \Omega} (\isTerm{t} \annotate A)^{\syn}$, it is decidable whether $\Gamma |- \isTerm{t} \chk A$ by induction hypothesis.
      \begin{itemize}
        \item If $\Gamma |- \isTerm{t} \chk A$, then $\Gamma |- \isTerm{t \annotate A} \syn A$.
        \item If $\Gamma \not|- t \chk A$ but $\Gamma |- \isTerm{t \annotate A} \syn$, then by inversion $\Gamma |- t \chk A$, leading to a contradiction.
      \end{itemize}
      
    \item \ChkRule{Sub}: For $\erase{\Gamma} |-_{\Sigma, \Omega}t^{\chk}$ by the rule $\ChkRule{Sub}$, we show that for any type $A$ it is decidable whether $\Gamma |-_{\Sigma, \Omega} t \chk A$.
      First, by induction hypothesis, it is decidable whether $\Gamma |- t \syn B$ for some $B$:
      \begin{itemize}
        \item If $\Gamma \not|- t \syn C$ for any type $C$ but $\Gamma |- t \chk A$ is derivable, then by inversion $\Gamma |- t \syn B$ for some $B = A$, thus a contradiction.
        \item If $\Gamma |- t \syn B$ for some $B$, then either $A = B$ or $A \neq B$ by the decidable equality on $\Type_{\Sigma}(\Xi)$: 
          \begin{itemize}
            \item if $A = B$ then we have\/ $\Gamma |- t \chk A$;
            \item if $A \neq B$ but $\Gamma |- t \chk A$, then by inversion $\Gamma |- t \syn A$.
              However, by \Cref{thm:unique-syn}, synthesised types $A$ and $B$ must be equal, so we derive a contradiction.
          \end{itemize}
      \end{itemize}
    \item \Rule{Op}:
      Consider the mode derivation of\/ $\erase{\Gamma} |-_{\Sigma, \Omega} \tmOpts^{\dir{d}}$ for an operation $o\colon \Xi \rhd [\Delta_{1}] A_{1}^{\dir{d}}, \ldots, [\Delta_n]A_{n}^{\dir{d_n}} \to A_0^{\dir{d}}$.
%
%  \begin{claim}\label{lem:args-induction}
%    For the argument list $\overrightarrow{[\Delta_i] A_{i}^{\dir{d_i}}}$, \emph{partial} substitution $\rho$ from $\Xi$ to $\emptyset$
%    \begin{enumerate}
%      \item either there is a minimal extension $\ext{\rho}$ of $\rho$ defined on $\synvar(\mathit{as})$ such that all of following judgements are derivable
%        \[
%          \Gamma, \vars{x}_\isTerm{i} : \simsub{\Delta_i}{\ext{\rho}} |-_{\Sigma, \Omega} \isTerm{t_i} \colon \simsub{A_i}{\ext{\rho}}^{\dir{d_i}}
%        \]
%
%      \item or there is no extension $\sigma$ of $\rho$ such that all $\Gamma, \vars{x}_\isTerm{i} : \simsub{\Delta_i}{\sigma} |-_{\Sigma, \Omega} \isTerm{t_i} \colon \simsub{A_i}{\sigma}^{\dir{d_i}}$ has a typing derivation. 
%    \end{enumerate}
%  \end{claim}
  \end{itemize}
\end{proof}

\subsection{Trichotomy on Raw Terms by Type Synthesis} \label{subsec:trichotomy}

%\begin{corollary}[Decidability of Bidirectional Type Synthesis] \label{thm:bidirectional-type-synthesis}
%  In a mode-correct bidirectional type system $(\Sigma, \Omega)$,
%  it is decidable whether there exists some $A$ such that
%  \[
%    \Gamma |-_{\Sigma, \Omega} \isTerm{t} \syn A.
%  \]
%\end{corollary}

\begin{corollary}[Trichotomy on Raw Terms]\label{cor:trichotomy}
  For any mode-correct bidirectional type system $(\Sigma, \Omega)$, 
  exactly one of the following holds:
  \begin{enumerate}
    \item $\erase{\Gamma} |-_{\Sigma, \Omega} \isTerm{t}^{\syn}$ and\/ $\Gamma |-_{\Sigma, \Omega} \isTerm{t} : A$ for some type $A$.
    \item $\erase{\Gamma} |-_{\Sigma, \Omega} \isTerm{t}^{\syn}$ but\/ $\Gamma \not|-_{\Sigma, \Omega} \isTerm{t} : A$.
    \item $\erase{\Gamma} \not|-_{\Sigma, \Omega} \isTerm{t}^{\syn}$.
  \end{enumerate}
\end{corollary}
\begin{proof}
  Combine \Cref{lem:soundness-completeness,thm:mode-preprocessing} with \Cref{thm:bidirectional-type-synthesis-checking}.
  
\end{proof}
